<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Shang Liang Liang&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2026-01-17T13:32:31.804Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Shang Liang Liang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Clojure10 - Apply源码分析和应用场景</title>
    <link href="http://yoursite.com/2022/04/26/Clojure/Clojure10%20-%20Apply%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%92%8C%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <id>http://yoursite.com/2022/04/26/Clojure/Clojure10%20-%20Apply%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%92%8C%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</id>
    <published>2022-04-25T16:00:00.000Z</published>
    <updated>2026-01-17T13:32:31.804Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Apply源码分析和应用场景"><a href="#Apply源码分析和应用场景" class="headerlink" title="Apply源码分析和应用场景"></a>Apply源码分析和应用场景</h1><h2 id="函数形式"><a href="#函数形式" class="headerlink" title="函数形式"></a>函数形式</h2><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(<span class="hljs-name"><span class="hljs-builtin-name">apply</span></span> f args)<br>(<span class="hljs-name"><span class="hljs-builtin-name">apply</span></span> f x args)<br>(<span class="hljs-name"><span class="hljs-builtin-name">apply</span></span> f x y args)<br>(<span class="hljs-name"><span class="hljs-builtin-name">apply</span></span> f x y z args)<br>(<span class="hljs-name"><span class="hljs-builtin-name">apply</span></span> f a b c d &amp; args)<br></code></pre></td></tr></table></figure><h2 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h2><p><strong>Applies fn f to the argument list formed by prepending intervening arguments to args.</strong></p><p>先将arguments插入到args的前面（也就是将x y z a b c d这些参数插入到args这个列表的前面，比如参数部分的形式是这样，x y [1 2 3]，那么先将参数整理成[x y 1 2 3]这种形式），再将函数f应用到这个整理后的参数列表上。</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> apply<br>  <span class="hljs-string">"Applies fn f to the argument list formed by prepending intervening arguments to args."</span><br>  &#123;<span class="hljs-symbol">:added</span> <span class="hljs-string">"1.0"</span><br>   <span class="hljs-symbol">:static</span> <span class="hljs-literal">true</span>&#125;<br>  ([<span class="hljs-comment">^clojure.lang.IFn</span> f args]<br>     (<span class="hljs-name"><span class="hljs-builtin-name">.</span></span> f (<span class="hljs-name">applyTo</span> (<span class="hljs-name"><span class="hljs-builtin-name">seq</span></span> args))))<br>  ([<span class="hljs-comment">^clojure.lang.IFn</span> f x args]<br>     (<span class="hljs-name"><span class="hljs-builtin-name">.</span></span> f (<span class="hljs-name">applyTo</span> (<span class="hljs-name"><span class="hljs-builtin-name">list*</span></span> x args))))<br>  ([<span class="hljs-comment">^clojure.lang.IFn</span> f x y args]<br>     (<span class="hljs-name"><span class="hljs-builtin-name">.</span></span> f (<span class="hljs-name">applyTo</span> (<span class="hljs-name"><span class="hljs-builtin-name">list*</span></span> x y args))))<br>  ([<span class="hljs-comment">^clojure.lang.IFn</span> f x y z args]<br>     (<span class="hljs-name"><span class="hljs-builtin-name">.</span></span> f (<span class="hljs-name">applyTo</span> (<span class="hljs-name"><span class="hljs-builtin-name">list*</span></span> x y z args))))<br>  ([<span class="hljs-comment">^clojure.lang.IFn</span> f a b c d &amp; args]<br>     (<span class="hljs-name"><span class="hljs-builtin-name">.</span></span> f (<span class="hljs-name">applyTo</span> (<span class="hljs-name"><span class="hljs-builtin-name">cons</span></span> a (<span class="hljs-name"><span class="hljs-builtin-name">cons</span></span> b (<span class="hljs-name"><span class="hljs-builtin-name">cons</span></span> c (<span class="hljs-name"><span class="hljs-builtin-name">cons</span></span> d (<span class="hljs-name"><span class="hljs-builtin-name">spread</span></span> args)))))))))<br></code></pre></td></tr></table></figure><p>注：clojure中的每个函数都实现了IFn接口，而AFn是实现了IFn接口的抽象类，位于clojure.lang包下面。在AFn抽象类中，包含了apply方法。</p><p>apply先将变长参数部分（arguments）插入到列表式参数（args）的前端，然后再调用f的applyTo方法。<br>applyTo的方法代码如下，利用了Helper方法，Helper主要是完成从列表到独立参数的转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">applyTo</span><span class="hljs-params">(ISeq arglist)</span> </span>&#123;<br><span class="hljs-keyword">return</span> applyToHelper(<span class="hljs-keyword">this</span>, Util.ret1(arglist,arglist = <span class="hljs-keyword">null</span>));<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="为什么要在Clojure中使用Apply？"><a href="#为什么要在Clojure中使用Apply？" class="headerlink" title="为什么要在Clojure中使用Apply？"></a>为什么要在Clojure中使用Apply？</h2><ol><li>如果传递给函数的参数数量<strong>在编译时</strong>是未知的,那么你会使用<em>apply</em>:</li></ol><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(<span class="hljs-name">define</span> (<span class="hljs-name">call-other-1</span> func arg) (<span class="hljs-name">func</span> arg))<br>(<span class="hljs-name">define</span> (<span class="hljs-name">call-other-2</span> func arg1 arg2) (<span class="hljs-name">func</span> arg1 arg2))<br></code></pre></td></tr></table></figure><p>只要在编译时知道参数的数量,就可以直接传递它们,如上例所示.但是如果在编译时不知道参数的数量,你就不能这样做:(下面是个坏例子)</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(<span class="hljs-name">define</span> (<span class="hljs-name">call-other-n</span> func . args)<br>   (<span class="hljs-name"><span class="hljs-builtin-name">case</span></span> (<span class="hljs-name">length</span> args)<br>      ((<span class="hljs-number">0</span>) (<span class="hljs-name">other</span>))<br>      ((<span class="hljs-number">1</span>) (<span class="hljs-name">other</span> (<span class="hljs-name">car</span> args)))<br>      ((<span class="hljs-number">2</span>) (<span class="hljs-name">other</span> (<span class="hljs-name">car</span> args) (<span class="hljs-name">cadr</span> args)))<br>      ...))<br></code></pre></td></tr></table></figure><p>但这很快就变成了一场噩梦:</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(<span class="hljs-name">define</span> (<span class="hljs-name">call-other-n</span> func . args)<br>   (<span class="hljs-name"><span class="hljs-builtin-name">apply</span></span> other args))<br></code></pre></td></tr></table></figure><p>它接受作为最后一个参数给出的列表中包含的任意数量的参数,并调用作为第一个参数传递的函数来<em>应用</em>这些值.</p><ol start="2"><li>apply 把给定的集合里面的所有元素一次性地给指定的函数作为参数调用，然后返回这个函数的返回值。所以apply与map的区别就是map返回的还是一个集合，而apply返回的是一个元素， 可以把apply看作是SQL里面的聚合函数。比如：</li></ol><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(<span class="hljs-name"><span class="hljs-builtin-name">apply</span></span> + [<span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">7</span>])<span class="hljs-comment">; -&gt; 13</span><br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Apply源码分析和应用场景&quot;&gt;&lt;a href=&quot;#Apply源码分析和应用场景&quot; class=&quot;headerlink&quot; title=&quot;Apply源码分析和应用场景&quot;&gt;&lt;/a&gt;Apply源码分析和应用场景&lt;/h1&gt;&lt;h2 id=&quot;函数形式&quot;&gt;&lt;a href=&quot;#函
      
    
    </summary>
    
    
      <category term="Clojure" scheme="http://yoursite.com/categories/Clojure/"/>
    
    
      <category term="Clojure" scheme="http://yoursite.com/tags/Clojure/"/>
    
  </entry>
  
  <entry>
    <title>Clojure07 - 运算符</title>
    <link href="http://yoursite.com/2022/04/21/Clojure/Clojure07%20-%20%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <id>http://yoursite.com/2022/04/21/Clojure/Clojure07%20-%20%E8%BF%90%E7%AE%97%E7%AC%A6/</id>
    <published>2022-04-20T16:00:00.000Z</published>
    <updated>2026-01-17T13:32:31.786Z</updated>
    
    <content type="html"><![CDATA[<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><p><strong>operator</strong>是一个符号，告诉编译器执行特定的数学或逻辑操作。</p><p>Clojure有以下类型的运算符 -</p><ul><li>算术运算符</li><li>关系运算符</li><li>逻辑运算符</li><li>按位运算符</li></ul><p><strong>Note</strong> - 在Clojure中，运算符和操作数以下列语法方式工作。</p><p>语法 (Syntax)</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(<span class="hljs-name">operator</span> operand1 operand2 operandn)<br></code></pre></td></tr></table></figure><h2 id="算术运算符-Arithmetic-Operators"><a href="#算术运算符-Arithmetic-Operators" class="headerlink" title="算术运算符 (Arithmetic Operators)"></a>算术运算符 (Arithmetic Operators)</h2><p>Clojure语言支持普通的算术运算符作为任何语言。 以下是Clojure中提供的算术运算符。</p><table><thead><tr><th align="center">操作者</th><th align="center">描述</th><th align="center">例</th></tr></thead><tbody><tr><td align="center">+</td><td align="center">增加了两个操作数</td><td align="center">（+ 1 2）将给出3</td></tr><tr><td align="center">−</td><td align="center">从第一个减去第二个操作数</td><td align="center">（ - 2 1）将给1</td></tr><tr><td align="center">*</td><td align="center">两个操作数的乘法</td><td align="center">（* 2 2）将给出4</td></tr><tr><td align="center">/</td><td align="center">由分母划分的分子</td><td align="center">（float（/ 3 2））将给出1.5</td></tr><tr><td align="center">inc</td><td align="center">增量运算符用于将操作数的值递增1</td><td align="center">公司5将给6</td></tr><tr><td align="center">dec</td><td align="center">增量运算符用于将操作数的值减1</td><td align="center">12月5日将给4</td></tr><tr><td align="center">max</td><td align="center">返回其最大的参数</td><td align="center">最大1 2 3将返回3</td></tr><tr><td align="center">min</td><td align="center">返回其最小的参数</td><td align="center">min 1 2 3将返回1</td></tr><tr><td align="center">rem</td><td align="center">将第一个数除以第二个数的余数</td><td align="center">rem 3 2将给出1</td></tr></tbody></table><h4 id="例子-Example"><a href="#例子-Example" class="headerlink" title="例子 (Example)"></a>例子 (Example)</h4><p>以下代码段显示了如何使用各种运算符。</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(<span class="hljs-name"><span class="hljs-builtin-name">ns</span></span> clojure.examples.hello<br>   (<span class="hljs-symbol">:gen-class</span>))<br><span class="hljs-comment">;; This program displays Hello World</span><br>(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> Example []<br>   (<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> x (<span class="hljs-name"><span class="hljs-builtin-name">+</span></span> <span class="hljs-number">2</span> <span class="hljs-number">2</span>))<br>   (<span class="hljs-name">println</span> x)<br>   (<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> x (<span class="hljs-name"><span class="hljs-builtin-name">-</span></span> <span class="hljs-number">2</span> <span class="hljs-number">1</span>))<br>   (<span class="hljs-name">println</span> x)<br>   (<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> x (<span class="hljs-name"><span class="hljs-builtin-name">*</span></span> <span class="hljs-number">2</span> <span class="hljs-number">2</span>))<br>   (<span class="hljs-name">println</span> x)<br>   (<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> x (<span class="hljs-name"><span class="hljs-builtin-name">float</span></span>(/ <span class="hljs-number">2</span> <span class="hljs-number">1</span>)))<br>   (<span class="hljs-name">println</span> x)<br>   (<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> x (<span class="hljs-name"><span class="hljs-builtin-name">inc</span></span> <span class="hljs-number">2</span>))<br>   (<span class="hljs-name">println</span> x)<br>   (<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> x (<span class="hljs-name"><span class="hljs-builtin-name">dec</span></span> <span class="hljs-number">2</span>))<br>   (<span class="hljs-name">println</span> x)<br>   (<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> x (<span class="hljs-name"><span class="hljs-builtin-name">max</span></span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>))<br>   (<span class="hljs-name">println</span> x)<br>   (<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> x (<span class="hljs-name"><span class="hljs-builtin-name">min</span></span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>))<br>   (<span class="hljs-name">println</span> x)<br>   (<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> x (<span class="hljs-name"><span class="hljs-builtin-name">rem</span></span> <span class="hljs-number">3</span> <span class="hljs-number">2</span>))<br>   (<span class="hljs-name">println</span> x))<br>(<span class="hljs-name">Example</span>)<br></code></pre></td></tr></table></figure><p>上述程序产生以下输出。</p><h4 id="输出-Output"><a href="#输出-Output" class="headerlink" title="输出 (Output)"></a>输出 (Output)</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">4<br>1<br>4<br>2.0<br>3<br>1<br>3<br>1<br>1<br></code></pre></td></tr></table></figure><h2 id="关系运算符-Relational-Operators"><a href="#关系运算符-Relational-Operators" class="headerlink" title="关系运算符 (Relational Operators)"></a>关系运算符 (Relational Operators)</h2><p>关系运算符允许比较对象。 以下是Clojure中提供的关系运算符。</p><table><thead><tr><th align="center">操作者</th><th align="center">描述</th><th align="center">例</th></tr></thead><tbody><tr><td align="center">=</td><td align="center">测试两个对象之间的相等性</td><td align="center">（= 2 2）将给出真实</td></tr><tr><td align="center">not=</td><td align="center">测试两个对象之间的差异</td><td align="center">（不是= 3 2）会给出真实的</td></tr><tr><td align="center">&lt;</td><td align="center">检查左对象是否小于右操作数</td><td align="center">（&lt;2 3）将给出真实</td></tr><tr><td align="center">&lt;=</td><td align="center">检查左对象是否小于或等于右操作数</td><td align="center">（&lt;= 2 3）将给出真实</td></tr><tr><td align="center">&gt;</td><td align="center">检查左对象是否大于右操作数</td><td align="center">（&gt; 3 2）将给出真实</td></tr><tr><td align="center">&gt;=</td><td align="center">检查左对象是否大于或等于右操作数</td><td align="center">（&gt; = 3 2）将给出真实</td></tr></tbody></table><h4 id="例子-Example-1"><a href="#例子-Example-1" class="headerlink" title="例子 (Example)"></a>例子 (Example)</h4><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(<span class="hljs-name"><span class="hljs-builtin-name">ns</span></span> clojure.examples.hello<br>   (<span class="hljs-symbol">:gen-class</span>))<br><span class="hljs-comment">;; This program displays Hello World</span><br>(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> Example []<br>   (<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> x (<span class="hljs-name"><span class="hljs-builtin-name">=</span></span> <span class="hljs-number">2</span> <span class="hljs-number">2</span>))<br>   (<span class="hljs-name">println</span> x)<br>   (<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> x (<span class="hljs-name"><span class="hljs-builtin-name">not=</span></span> <span class="hljs-number">3</span> <span class="hljs-number">2</span>))<br>   (<span class="hljs-name">println</span> x)<br>   (<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> x (<span class="hljs-name"><span class="hljs-builtin-name">&lt;</span></span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>))<br>   (<span class="hljs-name">println</span> x)<br>   (<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> x (<span class="hljs-name"><span class="hljs-builtin-name">&lt;=</span></span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>))<br>   (<span class="hljs-name">println</span> x)<br>   (<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> x (<span class="hljs-name"><span class="hljs-builtin-name">&gt;</span></span> <span class="hljs-number">3</span> <span class="hljs-number">2</span>))<br>   (<span class="hljs-name">println</span> x)<br>   (<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> x (<span class="hljs-name"><span class="hljs-builtin-name">&gt;=</span></span> <span class="hljs-number">3</span> <span class="hljs-number">2</span>))<br>   (<span class="hljs-name">println</span> x))<br>(<span class="hljs-name">Example</span>)<br></code></pre></td></tr></table></figure><p>上述程序产生以下输出。</p><h4 id="输出-Output-1"><a href="#输出-Output-1" class="headerlink" title="输出 (Output)"></a>输出 (Output)</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">true<br>true<br>true<br>true<br>true<br>true<br></code></pre></td></tr></table></figure><h2 id="逻辑运算符-Logical-Operators"><a href="#逻辑运算符-Logical-Operators" class="headerlink" title="逻辑运算符 (Logical Operators)"></a>逻辑运算符 (Logical Operators)</h2><p>逻辑运算符用于计算布尔表达式。 以下是Groovy中可用的逻辑运算符。</p><table><thead><tr><th align="center">操作者</th><th align="center">描述</th><th align="center">例</th></tr></thead><tbody><tr><td align="center"><strong>and</strong></td><td align="center">这是逻辑“和”运算符</td><td align="center">（或者说真的）会给出真实的</td></tr><tr><td align="center"><strong>or</strong></td><td align="center">这是逻辑“或”运算符</td><td align="center">（而真假）会给出错误的</td></tr><tr><td align="center"><strong>not</strong></td><td align="center">这是逻辑“非”运算符</td><td align="center">（不是假的）会给出真实的</td></tr></tbody></table><h4 id="例子-Example-2"><a href="#例子-Example-2" class="headerlink" title="例子 (Example)"></a>例子 (Example)</h4><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(<span class="hljs-name"><span class="hljs-builtin-name">ns</span></span> clojure.examples.hello<br>   (<span class="hljs-symbol">:gen-class</span>))<br><span class="hljs-comment">;; This program displays Hello World</span><br>(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> Example []<br>   (<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> x (<span class="hljs-name"><span class="hljs-builtin-name">or</span></span> <span class="hljs-literal">true</span> <span class="hljs-literal">true</span>))<br>   (<span class="hljs-name">println</span> x)<br>   (<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> x (<span class="hljs-name"><span class="hljs-builtin-name">and</span></span> <span class="hljs-literal">true</span> <span class="hljs-literal">false</span>))<br>   (<span class="hljs-name">println</span> x)<br>   (<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> x (<span class="hljs-name"><span class="hljs-builtin-name">not</span></span> <span class="hljs-literal">true</span>))<br>   (<span class="hljs-name">println</span> x))<br>(<span class="hljs-name">Example</span>)<br></code></pre></td></tr></table></figure><p>上述程序产生以下输出。</p><h4 id="输出-Output-2"><a href="#输出-Output-2" class="headerlink" title="输出 (Output)"></a>输出 (Output)</h4><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clojure"><span class="hljs-literal">true</span><br><span class="hljs-literal">false</span><br><span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><h2 id="按位运算符-Bitwise-Operators"><a href="#按位运算符-Bitwise-Operators" class="headerlink" title="按位运算符 (Bitwise Operators)"></a>按位运算符 (Bitwise Operators)</h2><p>Clojure提供了四个按位运算符。 以下是Clojure中可用的按位运算符。</p><table><thead><tr><th align="center">Sr.No.</th><th align="center">操作符和说明</th></tr></thead><tbody><tr><td align="center">1</td><td align="center"><strong>bit-and</strong>这是按位“和”运算符</td></tr><tr><td align="center">2</td><td align="center"><strong>bit-or</strong>这是按位“或”运算符</td></tr><tr><td align="center">3</td><td align="center"><strong>bit-xor</strong>这是按位“xor”或“Exclusive”或“运算符”</td></tr><tr><td align="center">4</td><td align="center"><strong>bit-not</strong>这是按位否定运算符</td></tr></tbody></table><p>以下是展示这些运算符的真值表。</p><table><thead><tr><th align="center">p</th><th align="center">q</th><th align="center">p＆Q</th><th align="center">p | q</th><th align="center">p ^ q</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">1</td></tr><tr><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">0</td></tr><tr><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">1</td></tr></tbody></table><h4 id="例子-Example-3"><a href="#例子-Example-3" class="headerlink" title="例子 (Example)"></a>例子 (Example)</h4><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(<span class="hljs-name"><span class="hljs-builtin-name">ns</span></span> clojure.examples.hello<br>   (<span class="hljs-symbol">:gen-class</span>))<br><span class="hljs-comment">;; This program displays Hello World</span><br>(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> Example []<br>   (<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> x (<span class="hljs-name">bit-and</span> <span class="hljs-number">00111100</span> <span class="hljs-number">00001101</span>))<br>   (<span class="hljs-name">println</span> x)<br>   (<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> x (<span class="hljs-name">bit-or</span> <span class="hljs-number">00111100</span> <span class="hljs-number">00001101</span>))<br>   (<span class="hljs-name">println</span> x)<br>   (<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> x (<span class="hljs-name">bit-xor</span> <span class="hljs-number">00111100</span> <span class="hljs-number">00001101</span>))<br>   (<span class="hljs-name">println</span> x)) <br>(<span class="hljs-name">Example</span>)<br></code></pre></td></tr></table></figure><p>上述程序产生以下输出。</p><h4 id="输出-Output-3"><a href="#输出-Output-3" class="headerlink" title="输出 (Output)"></a>输出 (Output)</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">576<br>37441<br>36865<br></code></pre></td></tr></table></figure><h2 id="运算符优先级-Operator-Precedence"><a href="#运算符优先级-Operator-Precedence" class="headerlink" title="运算符优先级 (Operator Precedence)"></a>运算符优先级 (Operator Precedence)</h2><p>与LISP一般情况一样，无需担心运算符优先级。 这是S-Expressions和前缀表示法的好处之一。 所有功能都从左到右，从里到外进行评估。 Clojure中的运算符只是函数，一切都是完全括号的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;运算符&quot;&gt;&lt;a href=&quot;#运算符&quot; class=&quot;headerlink&quot; title=&quot;运算符&quot;&gt;&lt;/a&gt;运算符&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;operator&lt;/strong&gt;是一个符号，告诉编译器执行特定的数学或逻辑操作。&lt;/p&gt;
&lt;p&gt;Clojure有以
      
    
    </summary>
    
    
      <category term="Clojure" scheme="http://yoursite.com/categories/Clojure/"/>
    
    
      <category term="Clojure" scheme="http://yoursite.com/tags/Clojure/"/>
    
  </entry>
  
  <entry>
    <title>Clojure08 - 条件语句</title>
    <link href="http://yoursite.com/2022/04/21/Clojure/Clojure08%20-%20%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5/"/>
    <id>http://yoursite.com/2022/04/21/Clojure/Clojure08%20-%20%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5/</id>
    <published>2022-04-20T16:00:00.000Z</published>
    <updated>2026-01-17T13:32:31.746Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="Clojure" scheme="http://yoursite.com/categories/Clojure/"/>
    
    
      <category term="Clojure" scheme="http://yoursite.com/tags/Clojure/"/>
    
  </entry>
  
  <entry>
    <title>Clojure09 - 循环</title>
    <link href="http://yoursite.com/2022/04/21/Clojure/Clojure09%20-%20%E5%BE%AA%E7%8E%AF/"/>
    <id>http://yoursite.com/2022/04/21/Clojure/Clojure09%20-%20%E5%BE%AA%E7%8E%AF/</id>
    <published>2022-04-20T16:00:00.000Z</published>
    <updated>2026-01-17T13:32:31.705Z</updated>
    
    <content type="html"><![CDATA[<h1 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h1><p>到目前为止，我们已经看到了以顺序方式一个接一个地执行的语句。 此外，Clojure中提供了一些语句，用于改变程序逻辑中的控制流。 然后将它们分类为控制语句流程，我们将详细介绍。</p><h2 id="While-声明"><a href="#While-声明" class="headerlink" title="While 声明"></a>While 声明</h2><h3 id="语法-Syntax"><a href="#语法-Syntax" class="headerlink" title="语法 (Syntax)"></a>语法 (Syntax)</h3><p>以下是<strong>‘while’</strong>语句的语法。</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(<span class="hljs-name"><span class="hljs-builtin-name">while</span></span>(<span class="hljs-name">expression</span>)<br>   (<span class="hljs-name"><span class="hljs-builtin-name">do</span></span><br>      codeblock))<br></code></pre></td></tr></table></figure><p>通过首先计算条件表达式（布尔值）来执行while语句，如果结果为true，则执行while循环中的语句。 从while语句中的条件评估开始重复该过程。 此循环继续，直到条件评估为false。 当条件为假时，循环终止。 然后程序逻辑继续执行紧跟在while语句之后的语句。 以下是此循环的图解表示。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1ey4zekpoj20go0anjrj.jpg" alt="声明"></p><h3 id="例子-Example"><a href="#例子-Example" class="headerlink" title="例子 (Example)"></a>例子 (Example)</h3><p>以下是while循环语句的示例。</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(<span class="hljs-name"><span class="hljs-builtin-name">ns</span></span> clojure.examples.hello<br>   (<span class="hljs-symbol">:gen-class</span>))<br><span class="hljs-comment">;; This program displays Hello World</span><br>(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> Example []<br>   (<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> x (<span class="hljs-name"><span class="hljs-builtin-name">atom</span></span> <span class="hljs-number">1</span>))<br>   (<span class="hljs-name"><span class="hljs-builtin-name">while</span></span> ( &lt; @x <span class="hljs-number">5</span> )<br>      (<span class="hljs-name"><span class="hljs-builtin-name">do</span></span><br>         (<span class="hljs-name">println</span> @x)<br>         (<span class="hljs-name"><span class="hljs-builtin-name">swap!</span></span> x inc))))<br>(<span class="hljs-name">Example</span>)<br></code></pre></td></tr></table></figure><p>在上面的例子中，我们首先将’x’变量的值初始化为1.<strong>==注意我们使用的是原子值，这是一个可以修改的值==</strong>。 然后我们在while循环中的条件是我们正在评估表达式的条件，例如’x’应该小于5.直到’x’的值小于5，我们将打印’x的值’ ‘然后增加它的价值。 swap语句用于使用新的递增值填充’x’的atom变量。</p><h3 id="输出-Output"><a href="#输出-Output" class="headerlink" title="输出 (Output)"></a>输出 (Output)</h3><p>上面的代码产生以下输出。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">1<br>2<br>3<br>4<br></code></pre></td></tr></table></figure><h2 id="Doseq-声明"><a href="#Doseq-声明" class="headerlink" title="Doseq 声明"></a>Doseq 声明</h2><h3 id="语法-Syntax-1"><a href="#语法-Syntax-1" class="headerlink" title="语法 (Syntax)"></a>语法 (Syntax)</h3><p><strong>‘doseq’</strong>语句类似于许多其他编程语言中的’for each’语句。 doseq语句基本上用于迭代序列。</p><p>以下是doseq语句的一般语法。</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(<span class="hljs-name"><span class="hljs-builtin-name">doseq</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">sequence</span></span>)<br>   statement#1)<br></code></pre></td></tr></table></figure><p>以下是此循环的图解表示。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1ey7oqzzvj20go0bnglt.jpg" alt="Doseq声明"></p><h3 id="例子-Example-1"><a href="#例子-Example-1" class="headerlink" title="例子 (Example)"></a>例子 (Example)</h3><p>以下是doseq语句的示例。</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(<span class="hljs-name"><span class="hljs-builtin-name">ns</span></span> clojure.examples.hello<br>   (<span class="hljs-symbol">:gen-class</span>))<br><span class="hljs-comment">;; This program displays Hello World</span><br>(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> Example []<br>   (<span class="hljs-name"><span class="hljs-builtin-name">doseq</span></span> [n [<span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span>]]<br>   (<span class="hljs-name">println</span> n)))<br>(<span class="hljs-name">Example</span>)<br></code></pre></td></tr></table></figure><p>在上面的例子中，我们使用doseq语句迭代分配给变量n的值0,1和2的序列。 对于每次迭代，我们只是将值打印到控制台。</p><h3 id="输出-Output-1"><a href="#输出-Output-1" class="headerlink" title="输出 (Output)"></a>输出 (Output)</h3><p>上面的代码产生以下输出。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">0<br>1<br>2<br></code></pre></td></tr></table></figure><h2 id="Dotimes-声明"><a href="#Dotimes-声明" class="headerlink" title="Dotimes 声明"></a>Dotimes 声明</h2><p><strong>‘dotimes’</strong>语句用于执行语句’x’次。</p><h3 id="语法-Syntax-2"><a href="#语法-Syntax-2" class="headerlink" title="语法 (Syntax)"></a>语法 (Syntax)</h3><p>以下是doseq语句的一般语法。</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(<span class="hljs-name"><span class="hljs-builtin-name">dotimes</span></span> (<span class="hljs-name">variable</span> value)<br>   statement)<br></code></pre></td></tr></table></figure><p>其中value必须是一个数字，表示循环需要迭代的次数。</p><p>以下是此循环的图解表示。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1eya046y1j20go08tmx7.jpg" alt="Dotimes声明"></p><h3 id="例子-Example-2"><a href="#例子-Example-2" class="headerlink" title="例子 (Example)"></a>例子 (Example)</h3><p>以下是’doseq’语句的示例。</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(<span class="hljs-name"><span class="hljs-builtin-name">ns</span></span> clojure.examples.hello<br>   (<span class="hljs-symbol">:gen-class</span>))<br><span class="hljs-comment">;; This program displays Hello World</span><br>(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> Example []<br>   (<span class="hljs-name"><span class="hljs-builtin-name">dotimes</span></span> [n <span class="hljs-number">5</span>]<br>   (<span class="hljs-name">println</span> n)))<br>(<span class="hljs-name">Example</span>)<br></code></pre></td></tr></table></figure><p>在上面的例子中，如果执行println语句，我们使用dotimes语句重复该数字。 并且对于每次迭代，它还将变量n的值递增。</p><h3 id="输出-Output-2"><a href="#输出-Output-2" class="headerlink" title="输出 (Output)"></a>输出 (Output)</h3><p>上面的代码产生以下输出。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">0<br>1<br>2<br>3<br>4<br></code></pre></td></tr></table></figure><h2 id="Loop-声明"><a href="#Loop-声明" class="headerlink" title="Loop 声明"></a>Loop 声明</h2><p>循环特殊形式不像<strong>‘for’</strong>循环。 循环的用法与let绑定相同。 但是，循环设置递归点。 递归点旨在与<strong>recur</strong>一起使用，这意味着循环始终与recur一起使用。 要发生循环，为recurs指定的参数（arity）的数量必须与循环的绑定数一致。 这样，recur就会回到循环中。</p><h3 id="语法-Syntax-3"><a href="#语法-Syntax-3" class="headerlink" title="语法 (Syntax)"></a>语法 (Syntax)</h3><p>以下是循环语句的一般语法。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs clojure">loop [binding]<br>(condition<br>   (statement)<br>   (recur (binding)))<br></code></pre></td></tr></table></figure><p>以下是此循环的图解表示。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1eybwypnwj20go0dm0sw.jpg" alt="循环声明"></p><h3 id="例子-Example-3"><a href="#例子-Example-3" class="headerlink" title="例子 (Example)"></a>例子 (Example)</h3><p>以下是<strong>‘for-in’</strong>语句的示例。</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(<span class="hljs-name"><span class="hljs-builtin-name">ns</span></span> clojure.examples.hello<br>   (<span class="hljs-symbol">:gen-class</span>))<br><span class="hljs-comment">;; This program displays Hello World</span><br>(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> Example []<br>   (<span class="hljs-name"><span class="hljs-builtin-name">loop</span></span> [x <span class="hljs-number">10</span>]<br>      (<span class="hljs-name"><span class="hljs-builtin-name">when</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">&gt;</span></span> x <span class="hljs-number">1</span>)<br>         (<span class="hljs-name">println</span> x)<br>         (<span class="hljs-name"><span class="hljs-builtin-name">recur</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">-</span></span> x <span class="hljs-number">2</span>))))) <br>(<span class="hljs-name">Example</span>)<br></code></pre></td></tr></table></figure><p>在上面的例子中，我们首先使用loop语句将’x’的值绑定到10。 然后我们使用<strong>when condition clause</strong>来查看’x’的值是否小于1.然后我们将’x’的值打印到控制台并使用recur语句重复循环。 在’x’的值减2后重复循环。</p><h3 id="输出-Output-3"><a href="#输出-Output-3" class="headerlink" title="输出 (Output)"></a>输出 (Output)</h3><p>上面的代码产生以下输出。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">10<br>8<br>6<br>4<br>2<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;循环&quot;&gt;&lt;a href=&quot;#循环&quot; class=&quot;headerlink&quot; title=&quot;循环&quot;&gt;&lt;/a&gt;循环&lt;/h1&gt;&lt;p&gt;到目前为止，我们已经看到了以顺序方式一个接一个地执行的语句。 此外，Clojure中提供了一些语句，用于改变程序逻辑中的控制流。 然后将它们
      
    
    </summary>
    
    
      <category term="Clojure" scheme="http://yoursite.com/categories/Clojure/"/>
    
    
      <category term="Clojure" scheme="http://yoursite.com/tags/Clojure/"/>
    
  </entry>
  
  <entry>
    <title>Clojure06 - 序列</title>
    <link href="http://yoursite.com/2022/04/20/Clojure/Clojure06%20-%20%E5%BA%8F%E5%88%97/"/>
    <id>http://yoursite.com/2022/04/20/Clojure/Clojure06%20-%20%E5%BA%8F%E5%88%97/</id>
    <published>2022-04-19T16:00:00.000Z</published>
    <updated>2026-01-17T13:32:31.704Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Seq"><a href="#Seq" class="headerlink" title="Seq"></a>Seq</h4><ul><li>Clojure提供了很多函数来操作序列（sequence), 而序列是集合的逻辑视图。很多东西可以被看作序列：Java集合, Clojure的集合, 字符串, 流, 文件系统结构以及XML树. 从已经存在的clojure集合来创建新的集合的效率是非常高的，因为这里使用了 <a href="http://en.wikipedia.org/wiki/Persistent_data_structure" target="_blank" rel="noopener">persistent data structures</a> 的技术(这对于clojure在数据不可更改的情况下，同时要保持代码的高效率是非常重要的)。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Seq&quot;&gt;&lt;a href=&quot;#Seq&quot; class=&quot;headerlink&quot; title=&quot;Seq&quot;&gt;&lt;/a&gt;Seq&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;Clojure提供了很多函数来操作序列（sequence), 而序列是集合的逻辑视图。很多东西可以被看作序列：Java集
      
    
    </summary>
    
    
      <category term="Clojure" scheme="http://yoursite.com/categories/Clojure/"/>
    
    
      <category term="Clojure" scheme="http://yoursite.com/tags/Clojure/"/>
    
  </entry>
  
  <entry>
    <title>Clojure05 - 集合</title>
    <link href="http://yoursite.com/2022/04/19/Clojure/Clojure05%20-%20%E9%9B%86%E5%90%88/"/>
    <id>http://yoursite.com/2022/04/19/Clojure/Clojure05%20-%20%E9%9B%86%E5%90%88/</id>
    <published>2022-04-18T16:00:00.000Z</published>
    <updated>2026-01-17T13:32:31.746Z</updated>
    
    <content type="html"><![CDATA[<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><ul><li><h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><ul><li><p>Lists是一个有序的元素的集合 — 相当于java里面的LinkedList。这种集合对于那种一直要往最前面加一个元素，干掉最前面一个元素是非常高效的(O(1)) — 想到于java里面的堆栈, 但是没有高效的方法来获取第N个元素， 也没有高效的办法来修改第N个元素。</p><p>下面是创建同样的list的多种不同的方法：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> stooges (<span class="hljs-name"><span class="hljs-builtin-name">list</span></span> <span class="hljs-string">"Moe"</span> <span class="hljs-string">"Larry"</span> <span class="hljs-string">"Curly"</span>))<br>(<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> stooges (<span class="hljs-name"><span class="hljs-builtin-name">quote</span></span> (<span class="hljs-string">"Moe"</span> <span class="hljs-string">"Larry"</span> <span class="hljs-string">"Curly"</span>)))<br>(<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> stooges '(<span class="hljs-string">"Moe"</span> <span class="hljs-string">"Larry"</span> <span class="hljs-string">"Curly"</span>))<br></code></pre></td></tr></table></figure></li></ul></li><li><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><ul><li><p>Maps 保存从key到value的a对应关系 — key和value都可以是任意对象。key-value 组合被以一种可以按照key的顺序高效获取的方式保存着。</p><p>下面是创建map的一些方法， 其中逗号是为了提高可读性的，它是可选的，解析的时候会被当作空格忽略掉的。</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> popsicle-map<br>  (<span class="hljs-name"><span class="hljs-builtin-name">hash-map</span></span> <span class="hljs-symbol">:red</span> <span class="hljs-symbol">:cherry</span>, <span class="hljs-symbol">:green</span> <span class="hljs-symbol">:apple</span>, <span class="hljs-symbol">:purple</span> <span class="hljs-symbol">:grape</span>))<br>(<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> popsicle-map<br>  &#123;<span class="hljs-symbol">:red</span> <span class="hljs-symbol">:cherry</span>, <span class="hljs-symbol">:green</span> <span class="hljs-symbol">:apple</span>, <span class="hljs-symbol">:purple</span> <span class="hljs-symbol">:grape</span>&#125;) <span class="hljs-comment">; same as previous</span><br>(<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> popsicle-map<br>  (<span class="hljs-name"><span class="hljs-builtin-name">sorted-map</span></span> <span class="hljs-symbol">:red</span> <span class="hljs-symbol">:cherry</span>, <span class="hljs-symbol">:green</span> <span class="hljs-symbol">:apple</span>, <span class="hljs-symbol">:purple</span> <span class="hljs-symbol">:grape</span>))<br></code></pre></td></tr></table></figure><p>Map可以作为它的key的函数，同时如果key是keyword的话，那么key也可以作为map的函数。下面是三种获取:green所对应的值的方法：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(<span class="hljs-name"><span class="hljs-builtin-name">get</span></span> popsicle-map <span class="hljs-symbol">:green</span>)<br>(<span class="hljs-name">popsicle-map</span> <span class="hljs-symbol">:green</span>)<br>(<span class="hljs-symbol">:green</span> popsicle-map)<br></code></pre></td></tr></table></figure></li></ul></li></ul><ul><li><h4 id="vec"><a href="#vec" class="headerlink" title="vec"></a>vec</h4><ul><li><p>Vectors也是一种有序的集合。这种集合对于从最后面删除一个元素，或者获取最后面一个元素是非常高效的(O(1))。这意味着对于向vector里面添加元素使用conj被使用cons更高效。Vector对于以索引的方式访问某个元素（用nth命令）或者修改某个元素(用assoc)来说非常的高效。函数定义的时候指定参数列表用的就是vector。</p><p>下面是两种创建vector的方法：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> stooges (<span class="hljs-name"><span class="hljs-builtin-name">vector</span></span> <span class="hljs-string">"Moe"</span> <span class="hljs-string">"Larry"</span> <span class="hljs-string">"Curly"</span>))<br>(<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> stooges [<span class="hljs-string">"Moe"</span> <span class="hljs-string">"Larry"</span> <span class="hljs-string">"Curly"</span>])<br></code></pre></td></tr></table></figure></li></ul></li><li><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><ul><li><p>Sets 是一个包含不重复元素的集合。当我们要求集合里面的元素不可以重复，并且我们不要求集合里面的元素保持它们添加时候的顺序，那么sets是比较适合的。 Clojure 支持两种不同的set： 排序的和不排序的。如果添加到set里面的元素相互之间不能比较大小，那么一个 <code>ClassCastException</code> 异常会被抛出来。下面是一些创建set的方法:</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> stooges (<span class="hljs-name"><span class="hljs-builtin-name">hash-set</span></span> <span class="hljs-string">"Moe"</span> <span class="hljs-string">"Larry"</span> <span class="hljs-string">"Curly"</span>)) <span class="hljs-comment">; not sorted</span><br>(<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> stooges #&#123;<span class="hljs-string">"Moe"</span> <span class="hljs-string">"Larry"</span> <span class="hljs-string">"Curly"</span>&#125;) <span class="hljs-comment">; same as previous</span><br>(<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> stooges (<span class="hljs-name"><span class="hljs-builtin-name">sorted-set</span></span> <span class="hljs-string">"Moe"</span> <span class="hljs-string">"Larry"</span> <span class="hljs-string">"Curly"</span>))<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="5-defmulti"><a href="#5-defmulti" class="headerlink" title="5. defmulti"></a>5. defmulti</h3><p>宏 <code>defmulti</code> 和 <code>defmethod</code> 经常被用在一起来定义 multimethod. 宏 <code>defmulti</code> 的参数包括一个方法名以及一个dispatch函数，这个dispatch函数的返回值会被用来选择到底调用哪个重载的函数。宏 <code>defmethod</code> 的参数则包括方法名，dispatch的值， 参数列表以及方法体。一个特殊的dispatch值 <code>:default</code> 是用来表示默认情况的 — 即如果其它的dispatch值都不匹配的话，那么就调用这个方法。 <code>defmethod</code> 多定义的名字一样的方法，它们的参数个数必须一样。传给multimethod的参数会传给dipatch函数的。</p><p>下面是一个用multimethod来实现基于参数的类型来进行重载的例子：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(<span class="hljs-name"><span class="hljs-builtin-name">defmulti</span></span> what-am-i class) <span class="hljs-comment">; class is the dispatch function</span><br>(<span class="hljs-name"><span class="hljs-builtin-name">defmethod</span></span> what-am-i Number [arg] (<span class="hljs-name">println</span> arg <span class="hljs-string">"is a Number"</span>))<br>(<span class="hljs-name"><span class="hljs-builtin-name">defmethod</span></span> what-am-i String [arg] (<span class="hljs-name">println</span> arg <span class="hljs-string">"is a String"</span>))<br>(<span class="hljs-name"><span class="hljs-builtin-name">defmethod</span></span> what-am-i <span class="hljs-symbol">:default</span> [arg] (<span class="hljs-name">println</span> arg <span class="hljs-string">"is something else"</span>))<br>(<span class="hljs-name">what-am-i</span> <span class="hljs-number">19</span>) <span class="hljs-comment">; -&gt; 19 is a Number</span><br>(<span class="hljs-name">what-am-i</span> <span class="hljs-string">"Hello"</span>) <span class="hljs-comment">; -&gt; Hello is a String</span><br>(<span class="hljs-name">what-am-i</span> <span class="hljs-literal">true</span>) <span class="hljs-comment">; -&gt; true is something else</span><br></code></pre></td></tr></table></figure><h3 id="6-Simple-Sample"><a href="#6-Simple-Sample" class="headerlink" title="6. Simple Sample"></a>6. Simple Sample</h3><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clojure"><br><br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;集合&quot;&gt;&lt;a href=&quot;#集合&quot; class=&quot;headerlink&quot; title=&quot;集合&quot;&gt;&lt;/a&gt;集合&lt;/h1&gt;&lt;h3 id=&quot;Collection&quot;&gt;&lt;a href=&quot;#Collection&quot; class=&quot;headerlink&quot; title=&quot;Colle
      
    
    </summary>
    
    
      <category term="Clojure" scheme="http://yoursite.com/categories/Clojure/"/>
    
    
      <category term="Clojure" scheme="http://yoursite.com/tags/Clojure/"/>
    
  </entry>
  
  <entry>
    <title>Clojure04 - 数据类型与变量</title>
    <link href="http://yoursite.com/2022/04/19/Clojure/Clojure04%20-%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F/"/>
    <id>http://yoursite.com/2022/04/19/Clojure/Clojure04%20-%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F/</id>
    <published>2022-04-18T16:00:00.000Z</published>
    <updated>2026-01-17T13:32:31.804Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>Clojure提供各种<strong>built-in data types.</strong></p><h2 id="0-基本数据类型"><a href="#0-基本数据类型" class="headerlink" title="0. 基本数据类型"></a>0. 基本数据类型</h2><p>以下是Clojure中定义的数据类型列表。</p><ul><li><p><strong>Integers</strong> - 以下是Clojure中可用的整数表示。</p><ul><li><strong>Decimal Integers (Short, Long and Int)</strong> - 这些用于表示整数。 例如，1234。</li><li><strong>Octal Numbers</strong> - 这些用于表示八进制表示中的数字。 例如，012。</li><li><strong>Hexadecimal Numbers</strong> - 这些用于表示表示中的数字。 例如，0xff。</li><li><strong>Radix Numbers</strong> - 这些用于表示基数表示中的数字。 例如，2r1111，其中基数是2到36之间的整数，包括2和36。</li></ul></li><li><p><strong>Floating point</strong></p><ul><li>默认值用于表示32位浮点数。 例如，12.34。</li><li>另一种表示形式是科学记数法。 例如，1.35e-12。</li></ul></li><li><p><strong>char</strong> - 这定义了单个字符文字。 使用间隙符号定义字符。 例如，/ e。</p></li><li><p><strong>Boolean</strong> - 这表示一个布尔值，可以是true或false。</p></li><li><p><strong>String</strong> - 这些是以<strong>String</strong>形式表示的文本文字。 例如，“Hello World”。</p></li><li><p><strong>Nil</strong> - 这用于表示Clojure中的NULL值。</p></li><li><p><strong>Atom</strong> - Atoms提供了一种管理共享，同步，独立状态的方法。 它们是引用类型，如refs和vars。</p></li></ul><p><strong>数字类型取值范围</strong></p><p>由于Clojure中的所有数据类型都是从Java继承的，因此有界值与Java编程语言中的有限值相同。 下表显示了数字和小数文字的最大允许值。</p><table><thead><tr><th align="center">文字</th><th align="center">范围</th></tr></thead><tbody><tr><td align="center">Short</td><td align="center">-32,768 to 32,767</td></tr><tr><td align="center">int</td><td align="center">-2,147,483,648 to 2,147,483,647</td></tr><tr><td align="center">long</td><td align="center">-9,223,372,036,854,775,808至+ 9,223,372,036,854,775,807</td></tr><tr><td align="center">float</td><td align="center">1.40129846432481707e-45至3.40282346638528860e + 38</td></tr><tr><td align="center">double</td><td align="center">4.94065645841246544e-324d至1.79769313486231570e + 308d</td></tr></tbody></table><h2 id="1-引用数字类型"><a href="#1-引用数字类型" class="headerlink" title="1. 引用数字类型"></a>1. 引用数字类型</h2><p>除了基本类型之外，还允许使用以下对象类型（有时称为包装类型）。</p><table><thead><tr><th align="center">名称</th></tr></thead><tbody><tr><td align="center">java.lang.Byte</td></tr><tr><td align="center">java.lang.Short</td></tr><tr><td align="center">java.lang.Integer</td></tr><tr><td align="center">java.lang.Long</td></tr><tr><td align="center">java.lang.Float</td></tr><tr><td align="center">java.lang.Double</td></tr></tbody></table><h5 id="例子-Example"><a href="#例子-Example" class="headerlink" title="例子 (Example)"></a>例子 (Example)</h5><p>以下程序显示了一个合并的clojure代码，用于演示Clojure中的数据类型。</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(<span class="hljs-name"><span class="hljs-builtin-name">ns</span></span> clojure.examples.hello<br>   (<span class="hljs-symbol">:gen-class</span>))<br><span class="hljs-comment">;; This program displays Hello World</span><br>(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> Example []<br>   <span class="hljs-comment">;; The below code declares a integer variable</span><br>   (<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> x <span class="hljs-number">1</span>)<br>   <span class="hljs-comment">;; The below code declares a float variable</span><br>   (<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> y <span class="hljs-number">1.25</span>)<br>   <span class="hljs-comment">;; The below code declares a string variable</span><br>   (<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> str1 <span class="hljs-string">"Hello"</span>)<br>   (<span class="hljs-name">println</span> x)<br>   (<span class="hljs-name">println</span> y)<br>   (<span class="hljs-name">println</span> str1))<br>(<span class="hljs-name">Example</span>)<br></code></pre></td></tr></table></figure><h5 id="输出-Output"><a href="#输出-Output" class="headerlink" title="输出 (Output)"></a>输出 (Output)</h5><p>上述程序产生以下输出。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">1<br>1.25<br>Hello<br></code></pre></td></tr></table></figure><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="0-变量声明"><a href="#0-变量声明" class="headerlink" title="0. 变量声明"></a>0. 变量声明</h2><p>以下是定义变量的一般语法。</p><h3 id="语法-Syntax"><a href="#语法-Syntax" class="headerlink" title="语法 (Syntax)"></a>语法 (Syntax)</h3><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> var-name var-value)<br></code></pre></td></tr></table></figure><p>其中’var-name’是变量的名称，’var-value’是绑定到变量的值。</p><h3 id="例子-Example-1"><a href="#例子-Example-1" class="headerlink" title="例子 (Example)"></a>例子 (Example)</h3><p>以下是变量声明的示例。</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(<span class="hljs-name"><span class="hljs-builtin-name">ns</span></span> clojure.examples.hello<br>   (<span class="hljs-symbol">:gen-class</span>))<br><span class="hljs-comment">;; This program displays Hello World</span><br>(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> Example []<br>   <span class="hljs-comment">;; The below code declares a integer variable</span><br>   (<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> x <span class="hljs-number">1</span>)<br>   <span class="hljs-comment">;; The below code declares a float variable</span><br>   (<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> y <span class="hljs-number">1.25</span>)<br>   <span class="hljs-comment">;; The below code declares a string variable</span><br>   (<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> str1 <span class="hljs-string">"Hello"</span>)<br>   <span class="hljs-comment">;; The below code declares a boolean variable</span><br>   (<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> status <span class="hljs-literal">true</span>))<br>(<span class="hljs-name">Example</span>)<br></code></pre></td></tr></table></figure><h2 id="1-命名变量-Naming-Variables"><a href="#1-命名变量-Naming-Variables" class="headerlink" title="1. 命名变量 (Naming Variables)"></a>1. 命名变量 (Naming Variables)</h2><p>变量的名称可以由字母，数字和下划线字符组成。 它<strong>==必须以字母或下划线开头==</strong>。 大写和小写字母是不同的，因为Clojure就像Java一样区分大小写的编程语言。</p><h3 id="例子-Example-2"><a href="#例子-Example-2" class="headerlink" title="例子 (Example)"></a>例子 (Example)</h3><p>以下是Clojure中变量命名的一些示例。</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(<span class="hljs-name"><span class="hljs-builtin-name">ns</span></span> clojure.examples.hello<br>   (<span class="hljs-symbol">:gen-class</span>))<br><span class="hljs-comment">;; This program displays Hello World</span><br>(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> Example []<br>   <span class="hljs-comment">;; The below code declares a Boolean variable with the name of status</span><br>   (<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> status <span class="hljs-literal">true</span>)<br>   <span class="hljs-comment">;; The below code declares a Boolean variable with the name of STATUS</span><br>   (<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> STATUS <span class="hljs-literal">false</span>)<br>   <span class="hljs-comment">;; The below code declares a variable with an underscore character.</span><br>   (<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> _num1 <span class="hljs-number">2</span>))<br>(<span class="hljs-name">Example</span>)<br></code></pre></td></tr></table></figure><p><strong>Note</strong> - 在上面的语句中，由于区分大小写，status和STATUS是Clojure中定义的两个不同的变量。</p><p>上面的示例显示了如何使用下划线字符定义变量。</p><h2 id="2-打印变量-Printing-variables"><a href="#2-打印变量-Printing-variables" class="headerlink" title="2. 打印变量 (Printing variables)"></a>2. 打印变量 (Printing variables)</h2><p>由于Clojure使用JVM环境，您还可以使用’println’函数。 以下示例显示了如何实现此目的。</p><h3 id="例子-Example-3"><a href="#例子-Example-3" class="headerlink" title="例子 (Example)"></a>例子 (Example)</h3><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(<span class="hljs-name"><span class="hljs-builtin-name">ns</span></span> clojure.examples.hello<br>   (<span class="hljs-symbol">:gen-class</span>))<br><span class="hljs-comment">;; This program displays Hello World</span><br>(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> Example []<br>   <span class="hljs-comment">;; The below code declares a integer variable</span><br>   (<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> x <span class="hljs-number">1</span>)<br>   <span class="hljs-comment">;; The below code declares a float variable</span><br>   (<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> y <span class="hljs-number">1.25</span>)<br>   <span class="hljs-comment">;; The below code declares a string variable</span><br>   (<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> str1 <span class="hljs-string">"Hello"</span>)<br>   (<span class="hljs-name">println</span> x)<br>   (<span class="hljs-name">println</span> y)<br>   (<span class="hljs-name">println</span> str1))<br>(<span class="hljs-name">Example</span>)<br></code></pre></td></tr></table></figure><h3 id="输出-Output-1"><a href="#输出-Output-1" class="headerlink" title="输出 (Output)"></a>输出 (Output)</h3><p>上述程序产生以下输出。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">1<br>1.25<br>Hello<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据类型&quot;&gt;&lt;a href=&quot;#数据类型&quot; class=&quot;headerlink&quot; title=&quot;数据类型&quot;&gt;&lt;/a&gt;数据类型&lt;/h1&gt;&lt;p&gt;Clojure提供各种&lt;strong&gt;built-in data types.&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;0
      
    
    </summary>
    
    
      <category term="Clojure" scheme="http://yoursite.com/categories/Clojure/"/>
    
    
      <category term="Clojure" scheme="http://yoursite.com/tags/Clojure/"/>
    
  </entry>
  
  <entry>
    <title>Clojure03 - 语法</title>
    <link href="http://yoursite.com/2022/04/18/Clojure/Clojure03%20-%20%E8%AF%AD%E6%B3%95/"/>
    <id>http://yoursite.com/2022/04/18/Clojure/Clojure03%20-%20%E8%AF%AD%E6%B3%95/</id>
    <published>2022-04-17T16:00:00.000Z</published>
    <updated>2026-01-17T13:32:31.804Z</updated>
    
    <content type="html"><![CDATA[<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><p>一个典型的java方法调用是这样的:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">methodName(arg1, arg2, arg3);<br></code></pre></td></tr></table></figure><p>而Clojure的方法调用是这样的:</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(<span class="hljs-name">function-name</span> arg1 arg2 arg3)<br></code></pre></td></tr></table></figure><p>左括号被移到了最前面；逗号和分号不需要了. 我们称这种语法叫： “form”. 这种风格是简单而又美丽：Lisp里面所有东西都是这种风格的.要注意的是<strong>==clojure里面的命名规范是小写单词，如果是多个单词，那么通过中横线连接==</strong>。</p><p>为了理解Clojure的基本语法，让我们首先看一个简单的Hello World程序。</p><h2 id="Hello-World作为一个完整的程序"><a href="#Hello-World作为一个完整的程序" class="headerlink" title="Hello World作为一个完整的程序"></a>Hello World作为一个完整的程序</h2><p>在完整的Clojure程序中写下“Hello world”。 以下是一个例子。</p><h5 id="例子-Example"><a href="#例子-Example" class="headerlink" title="例子 (Example)"></a>例子 (Example)</h5><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(<span class="hljs-name"><span class="hljs-builtin-name">ns</span></span> clojure.examples.hello<br>   (<span class="hljs-symbol">:gen-class</span>))<br>(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> hello-world []<br>   (<span class="hljs-name">println</span> <span class="hljs-string">"Hello World"</span>))<br>(<span class="hljs-name">hello-world</span>)<br></code></pre></td></tr></table></figure><p>关于上述程序需要注意以下事项。</p><ul><li>该程序将写在一个名为main.clj的文件中。 扩展名“clj”是clojure代码文件的扩展名。 在上面的示例中，文件名称为main.clj。</li><li>‘defn’关键字用于定义函数。 我们将在另一章中详细介绍函数。 但是现在，知道我们正在创建一个名为helloworld的函数，它将具有我们的主要Clojure代码。</li><li>在我们的Clojure代码中，我们使用’println’语句将“Hello World”打印到控制台输出。</li><li>然后我们调用hello-world函数，然后运行’println’语句。</li></ul><p>上述程序产生以下输出。</p><h5 id="输出-Output"><a href="#输出-Output" class="headerlink" title="输出 (Output)"></a>输出 (Output)</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">Hello World<br></code></pre></td></tr></table></figure><h2 id="声明的一般形式"><a href="#声明的一般形式" class="headerlink" title="声明的一般形式"></a>声明的一般形式</h2><p>任何语句的一般形式都需要在大括号中进行评估，如以下示例所示。</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(<span class="hljs-name"><span class="hljs-builtin-name">+</span></span> <span class="hljs-number">1</span> <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>在上面的示例中，整个表达式用大括号括起来。 上述语句的输出为3. +运算符的作用类似于Clojure中的一个函数，用于添加数字。 值1和2被称为<strong>parameters to the function</strong> 。 </p><p>让我们考虑另一个例子。 在这个例子中，’str’是用于连接两个字符串的运算符。 字符串“Hello”和“World”用作参数。</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(<span class="hljs-name"><span class="hljs-builtin-name">str</span></span> <span class="hljs-string">"Hello"</span> <span class="hljs-string">"World"</span>)<br></code></pre></td></tr></table></figure><h5 id="例子-Example-1"><a href="#例子-Example-1" class="headerlink" title="例子 (Example)"></a>例子 (Example)</h5><p>如果我们结合上述两个语句并编写程序，它将如下所示。</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(<span class="hljs-name"><span class="hljs-builtin-name">ns</span></span> clojure.examples.hello<br>   (<span class="hljs-symbol">:gen-class</span>))<br>(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> Example []<br>   (<span class="hljs-name">println</span> (<span class="hljs-name"><span class="hljs-builtin-name">str</span></span> <span class="hljs-string">"Hello World"</span>))<br>   (<span class="hljs-name">println</span> (<span class="hljs-name"><span class="hljs-builtin-name">+</span></span> <span class="hljs-number">1</span> <span class="hljs-number">2</span>)))<br>(<span class="hljs-name">Example</span>)<br></code></pre></td></tr></table></figure><p>上述程序产生以下输出。</p><h5 id="输出-Output-1"><a href="#输出-Output-1" class="headerlink" title="输出 (Output)"></a>输出 (Output)</h5><p>上述程序产生以下输出。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">Hello World<br>3<br></code></pre></td></tr></table></figure><h2 id="Namespaces"><a href="#Namespaces" class="headerlink" title="Namespaces"></a>Namespaces</h2><p>命名空间用于定义Clojure中定义的模块之间的逻辑边界。</p><h5 id="当前命名空间"><a href="#当前命名空间" class="headerlink" title="当前命名空间"></a>当前命名空间</h5><p>这定义了当前Clojure代码所在的当前名称空间。</p><h5 id="语法-Syntax"><a href="#语法-Syntax" class="headerlink" title="语法 (Syntax)"></a>语法 (Syntax)</h5><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-strong">*ns*</span><br></code></pre></td></tr></table></figure><h5 id="例子-Example-2"><a href="#例子-Example-2" class="headerlink" title="例子 (Example)"></a>例子 (Example)</h5><p>在REPL命令窗口中，运行以下命令。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-strong">*ns*</span><br></code></pre></td></tr></table></figure><h5 id="输出-Output-2"><a href="#输出-Output-2" class="headerlink" title="输出 (Output)"></a>输出 (Output)</h5><p>当我们运行上面的命令时，输出将推迟，具体取决于当前命名空间。 以下是输出的示例。 Clojure代码的命名空间是 -</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs clojure">clojure.examples.hello<br>(ns clojure.examples.hello<br>   (:gen-class))<br>(defn Example []<br>   (println (str "Hello World"))<br>   (println (+ 1 2)))<br>(Example)<br></code></pre></td></tr></table></figure><h2 id="在Clojure中加载-java-包"><a href="#在Clojure中加载-java-包" class="headerlink" title="在Clojure中加载 java 包"></a>在Clojure中加载 java 包</h2><p>Clojure代码打包在库中。 每个Clojure库都属于一个名称空间，类似于Java包。 您可以使用“Require”语句加载Clojure库。</p><h5 id="语法-Syntax-1"><a href="#语法-Syntax-1" class="headerlink" title="语法 (Syntax)"></a>语法 (Syntax)</h5><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(<span class="hljs-name">require</span> quoted-namespace-symbol)<br></code></pre></td></tr></table></figure><h5 id="例子-Example-3"><a href="#例子-Example-3" class="headerlink" title="例子 (Example)"></a>例子 (Example)</h5><p>以下是此语句的使用示例。</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(<span class="hljs-name"><span class="hljs-builtin-name">ns</span></span> clojure.examples.hello<br>   (<span class="hljs-symbol">:gen-class</span>))<br>(<span class="hljs-name">require</span> ‘clojure.java.io’)<br>(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> Example []<br>   (<span class="hljs-name">.exists</span> (<span class="hljs-name">file</span> <span class="hljs-string">"Example.txt"</span>)))<br>(<span class="hljs-name">Example</span>)<br></code></pre></td></tr></table></figure><p>在上面的代码中，我们使用’require’关键字导入命名空间clojure.java.io，它具有输入/输出功能所需的所有功能。 由于我们没有所需的库，我们可以在上面的代码中使用’file’函数。</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>注释用于记录您的代码。 单行注释使用;; 在任何位置。 以下是一个例子。</p><h5 id="例子-Example-4"><a href="#例子-Example-4" class="headerlink" title="例子 (Example)"></a>例子 (Example)</h5><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(<span class="hljs-name"><span class="hljs-builtin-name">ns</span></span> clojure.examples.hello<br>   (<span class="hljs-symbol">:gen-class</span>))<br><span class="hljs-comment">;; This program displays Hello World</span><br>(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> Example []<br>   (<span class="hljs-name">println</span> <span class="hljs-string">"Hello World"</span>))<br>(<span class="hljs-name">Example</span>)<br></code></pre></td></tr></table></figure><h2 id="Delimiters-分隔符"><a href="#Delimiters-分隔符" class="headerlink" title="Delimiters(分隔符)"></a>Delimiters(分隔符)</h2><p>在Clojure中，可以使用弯曲或方括号括号来分割或分隔语句。</p><p>以下是两个例子。</p><h5 id="例子1-Example"><a href="#例子1-Example" class="headerlink" title="例子1 (Example)"></a>例子1 (Example)</h5><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(<span class="hljs-name"><span class="hljs-builtin-name">ns</span></span> clojure.examples.hello<br>   (<span class="hljs-symbol">:gen-class</span>))<br><span class="hljs-comment">;; This program displays Hello World</span><br>(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> Example []<br>   (<span class="hljs-name">println</span> (<span class="hljs-name"><span class="hljs-builtin-name">+</span></span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>)))<br>(<span class="hljs-name">Example</span>)<br></code></pre></td></tr></table></figure><h5 id="输出-Output-3"><a href="#输出-Output-3" class="headerlink" title="输出 (Output)"></a>输出 (Output)</h5><p>上述程序产生以下输出。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><h5 id="例子2-Example"><a href="#例子2-Example" class="headerlink" title="例子2 (Example)"></a>例子2 (Example)</h5><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(<span class="hljs-name"><span class="hljs-builtin-name">ns</span></span> clojure.examples.hello<br>   (<span class="hljs-symbol">:gen-class</span>))<br><span class="hljs-comment">;; This program displays Hello World</span><br>(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> Example []<br>   (<span class="hljs-name">println</span> [+ <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>]))<br>(<span class="hljs-name">Example</span>)<br><span class="hljs-number">1234567</span><br></code></pre></td></tr></table></figure><h5 id="输出-Output-4"><a href="#输出-Output-4" class="headerlink" title="输出 (Output)"></a>输出 (Output)</h5><p>上述程序产生以下输出。</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clojure">[#object[clojure.core$_PLUS_ <span class="hljs-number">0</span>x10f163b <span class="hljs-string">"clojure.core$_PLUS_@10f163b"</span>] <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>]<br><span class="hljs-number">12</span><br></code></pre></td></tr></table></figure><h2 id="Whitespaces"><a href="#Whitespaces" class="headerlink" title="Whitespaces"></a>Whitespaces</h2><p>可以在Clojure中使用空格来分割语句的不同组件，以便更清晰。 这可以在逗号（，）运算符的帮助下完成。</p><p>例如，以下两个语句是等效的，两个语句的输出都是15。</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(<span class="hljs-name"><span class="hljs-builtin-name">+</span></span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span>)<br>(<span class="hljs-name"><span class="hljs-builtin-name">+</span></span> <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><p>尽管Clojure忽略了逗号，但它有时会使用它们来让程序员更容易阅读。</p><p>例如，如果你有一个如下所示的哈希映射（def a-map {:a 1:b 2:c 3}）并在REPL窗口中询问它的值，Clojure会将输出打印为{:a 1， :b 2，:c 3}。</p><p>结果更容易阅读，特别是如果您正在查看大量数据。</p><h2 id="Symbols"><a href="#Symbols" class="headerlink" title="Symbols"></a>Symbols</h2><p>在Clojure中，符号等同于其他编程语言中的标识符。 但与其他编程语言不同，编译器将符号视为实际的字符串值。 由于符号是值，因此符号可以存储在集合中，作为参数传递给函数等，就像任何其他对象一样。</p><p><strong>符号只能包含字母数字字符和’* +！ /。 : - _？’ 但不能以数字或冒号开头。</strong></p><p>以下是符号的有效示例。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clojure">tutorial-point!<br>TUTORIAL<br>+tutorial+<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;语法&quot;&gt;&lt;a href=&quot;#语法&quot; class=&quot;headerlink&quot; title=&quot;语法&quot;&gt;&lt;/a&gt;语法&lt;/h1&gt;&lt;p&gt;一个典型的java方法调用是这样的:&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td c
      
    
    </summary>
    
    
      <category term="Clojure" scheme="http://yoursite.com/categories/Clojure/"/>
    
    
      <category term="Clojure" scheme="http://yoursite.com/tags/Clojure/"/>
    
  </entry>
  
  <entry>
    <title>Clojure02 - REPL</title>
    <link href="http://yoursite.com/2022/04/17/Clojure/Clojure02%20-%20REPL/"/>
    <id>http://yoursite.com/2022/04/17/Clojure/Clojure02%20-%20REPL/</id>
    <published>2022-04-16T16:00:00.000Z</published>
    <updated>2026-01-17T13:32:32.310Z</updated>
    
    <content type="html"><![CDATA[<h1 id="REPL"><a href="#REPL" class="headerlink" title="REPL"></a>REPL</h1><p>REPL（read-eval-print loop）是一个用于试验Clojure代码的工具。 它允许您与正在运行的程序进行交互，并快速尝试是否可以正常运行。 它通过向您提供输入代码的提示来完成此操作。 然后它会读取您的输入，对其进行评估，打印结果并循环，再次向您显示提示。</p><h2 id="0-启动REPL会话"><a href="#0-启动REPL会话" class="headerlink" title="0. 启动REPL会话"></a>0. 启动REPL会话</h2><p>通过在命令行中键入以下命令，可以在Leiningen中启动REPL会话。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">lein repl<br></code></pre></td></tr></table></figure><h2 id="1-运行clj"><a href="#1-运行clj" class="headerlink" title="1. 运行clj"></a>1. 运行clj</h2><ol><li>Terminal中</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd projectfolder<br>lein run<br></code></pre></td></tr></table></figure><ol start="2"><li>Lein REPL中</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">(-main)<br>(funciton1)<br></code></pre></td></tr></table></figure><h2 id="2-REPL中的特殊变量"><a href="#2-REPL中的特殊变量" class="headerlink" title="2. REPL中的特殊变量"></a>2. REPL中的特殊变量</h2><p>REPL包含一些有用的变量，广泛使用的变量是特殊变量* 1，* 2和* 3。 这些用于评估最近三个表达式的结果。</p><p>以下示例显示了如何使用这些变量。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">user =&gt; "Hello"<br>Hello<br>user =&gt; "World"<br>World<br>user =&gt; (str *2 *1)<br>HelloWorld<br>1234567<br></code></pre></td></tr></table></figure><p>在上面的例子中，前两个字符串分别作为“Hello”和“World”发送到REPL输出窗口。 然后使用* 2和* 1变量来调用最后2个评估的表达式。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;REPL&quot;&gt;&lt;a href=&quot;#REPL&quot; class=&quot;headerlink&quot; title=&quot;REPL&quot;&gt;&lt;/a&gt;REPL&lt;/h1&gt;&lt;p&gt;REPL（read-eval-print loop）是一个用于试验Clojure代码的工具。 它允许您与正在运行的程序进行交
      
    
    </summary>
    
    
      <category term="Clojure" scheme="http://yoursite.com/categories/Clojure/"/>
    
    
      <category term="Clojure" scheme="http://yoursite.com/tags/Clojure/"/>
    
  </entry>
  
  <entry>
    <title>Clojure01 - 安装</title>
    <link href="http://yoursite.com/2022/04/16/Clojure/Clojure01%20-%20%E5%AE%89%E8%A3%85/"/>
    <id>http://yoursite.com/2022/04/16/Clojure/Clojure01%20-%20%E5%AE%89%E8%A3%85/</id>
    <published>2022-04-15T16:00:00.000Z</published>
    <updated>2026-01-17T13:32:31.704Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Clojure"><a href="#Clojure" class="headerlink" title="Clojure"></a>Clojure</h1><h2 id="0-概述"><a href="#0-概述" class="headerlink" title="0. 概述"></a>0. 概述</h2><h4 id="纯粹的函数式编程"><a href="#纯粹的函数式编程" class="headerlink" title="纯粹的函数式编程"></a>纯粹的函数式编程</h4><p>函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，因此，==<strong>任意一个函数，只要输入是确定的，输出就是确定的</strong>==，这种纯函数我们称之为没有副作用。</p><p>纯函数的意思是同一个函数对于同样同样的参数，它的返回值始终是一样的 — 而不会因为前一次调用修改了某个全局变量而使得后面的调用和前面调用的结果不一样。这使得这种程序十分容易理解、调试、测试。它们没有副作用 — 修改某些全局变量， 进行一些IO操作（文件IO和数据库）。状态被维护在方法的参数上面， 而这些参数被存放在栈(stack)上面（通常通过递归调用）， 而不是被维护在全局的堆（heap）上面。这使得方面可以被执行多次而不用担心它会更改什么全局的状态（这是非常重要的特征，等我们讨论事务的时候你就会意识到了）。这也使得高级编译器为了提高代码性能而对代码进行重排(reording)和并行化(parallelizing)成为可能。（并行化代码现在还很少见）</p><h4 id="有副作用的函数式编程"><a href="#有副作用的函数式编程" class="headerlink" title="有副作用的函数式编程"></a>有副作用的函数式编程</h4><p>而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。</p><p>函数式编程的一个特点就是，<strong>允许把函数本身作为参数传入另一个函数，还允许返回一个函数</strong>！</p><p>接受函数作为参数的函数我们称为“高阶函数”。从某个方面来说，高阶函数的行为是由传进来的函数来配置的，这个函数可以被执行任意次，也可以从不执行。</p><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><p>函数式语言里面的数据是不可修改的。这使得多个线程可以在不用锁的情况下并发地访问这个数据。因为数据不会改变，所以根本不需要上锁。</p><h4 id="Clojure概述"><a href="#Clojure概述" class="headerlink" title="Clojure概述"></a>Clojure概述</h4><p>Clojure是一个动态类型的，运行在JVM(JDK5.0以上），并且可以和java代码互操作的函数式语言。这个语言的主要目标之一是使得编写一个有多个线程并发访问数据的程序变得简单。</p><p>运行在JVM上面使得Clojure代码具有可移植性，稳定性，可靠的性能以及安全性。同时也使得我们的Clojure代码可以访问丰富的已经存在的java类库：文件 I/O, 多线程, 数据库操作, GUI编程, web应用等等.</p><p>Clojure作为一种编程语言具有以下高级关键目标。</p><ul><li>它基于LISP编程语言，使其代码语句比传统编程语言更小。</li><li>它是一种函数式编程语言。</li><li>它侧重于不变性，这基本上是您不应该对就地创建的对象进行任何更改的概念。</li><li>它可以管理程序员的应用程序状态。</li><li>它支持并发。</li><li>它包含现有的编程语言。 例如，Clojure可以利用整个Java生态系统来管理通过JVM运行的代码</li></ul><p>Clojure里面的每个操作被实现成以下三种形式的一种: 函数(function), 宏(macro)或者special form. 几乎所有的函数和宏都是用Clojure代码实现的，Special forms不是用clojure代码实现的，而且被clojure的编译器识别出来. special forms的个数是很少的， 而且现在也不能再实现新的special forms了. 它们包括: <a href="http://clojure.org/special_forms#try" target="_blank" rel="noopener">catch</a> , <a href="http://clojure.org/special_forms#toc1" target="_blank" rel="noopener">def</a> , <a href="http://clojure.org/special_forms#toc3" target="_blank" rel="noopener">do</a> , <a href="http://clojure.org/java_interop#dot" target="_blank" rel="noopener">dot</a> (‘.’), <a href="http://clojure.org/special_forms#try" target="_blank" rel="noopener">finally</a> , <a href="http://clojure.org/special_forms#toc7" target="_blank" rel="noopener">fn</a> , <a href="http://clojure.org/special_forms#toc2" target="_blank" rel="noopener">if</a> , <a href="http://clojure.org/special_forms#toc4" target="_blank" rel="noopener">let</a> , <a href="http://clojure.org/special_forms#toc9" target="_blank" rel="noopener">loop</a> , <a href="http://clojure.org/special_forms#toc13" target="_blank" rel="noopener">monitor-enter</a> , <a href="http://clojure.org/special_forms#toc14" target="_blank" rel="noopener">monitor-exit</a> , <a href="http://clojure.org/java_interop#new" target="_blank" rel="noopener">new</a> , <a href="http://clojure.org/special_forms#toc5" target="_blank" rel="noopener">quote</a> , <a href="http://clojure.org/special_forms#toc10" target="_blank" rel="noopener">recur</a> , <a href="http://clojure.org/java_interop#set" target="_blank" rel="noopener">set!</a> , <a href="http://clojure.org/special_forms#try" target="_blank" rel="noopener">throw</a> , <a href="http://clojure.org/special_forms#try" target="_blank" rel="noopener">try</a> 和 <a href="http://clojure.org/special_forms#toc6" target="_blank" rel="noopener">var</a> .</p><p>Clojure提供三种方法来安全地共享可修改的数据。所有三种方法的实现方式都是持有一个可以开遍的引用指向一个不可改变的数据。</p><ul><li>Refs通过使用 <a href="http://en.wikipedia.org/wiki/Software_transactional_memory" target="_blank" rel="noopener">Software Transactional Memory</a> （STM）来提供对于多块共享数据的同步访问。</li><li>Atoms提供对于单个共享数据的同步访问。</li><li>Agents提供对于单个共享数据的异步访问。</li></ul><p>对Clojure代码的处理分为三个阶段：读入期，编译期以及运行期。</p><ul><li>在读入期，读入期会读取clojure源代码并且把代码转变成数据结构，基本上来说就是一个包含列表的列表的列表。</li><li>在编译期，这些数据结构被转化成java的bytecode。</li><li>在运行期，这些java bytecode被执行。函数只有在运行期才会执行。而宏在编译期就被展开成实际对应的代码了。</li></ul><h2 id="1-Clojure安装"><a href="#1-Clojure安装" class="headerlink" title="1. Clojure安装"></a>1. Clojure安装</h2><ul><li><p>安装Leiningen</p><ul><li><p>MAC </p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">brew </span><span class="hljs-keyword">install </span>leiningen<br></code></pre></td></tr></table></figure></li><li><p>Linux</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">wget https:<span class="hljs-regexp">//</span>raw.githubusercontent.com<span class="hljs-regexp">/technomancy/</span>leiningen<span class="hljs-regexp">/stable/</span>bin<span class="hljs-regexp">/lein</span><br></code></pre></td></tr></table></figure></li><li><p>验证</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">lein <span class="hljs-built_in">version</span><br></code></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1a6izyuoaj217q06edhl.jpg" alt="image-20220415100627226"></p></li></ul></li><li><p>创建工程Lein</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs groovy">brew list<br>chmod a+x <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/Cellar/</span>leiningen<span class="hljs-regexp">/2.9.8/</span>bin/lein<br>sudo <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/Cellar/</span>leiningen<span class="hljs-regexp">/2.9.8/</span>bin/lein <br><br>lein <span class="hljs-keyword">new</span> app my-stuff<br>cd my-stuff<br><br>lein repl<br></code></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1aemymq3pj216g0u0jy8.jpg" alt="image-20220415144703424"></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1aes78r9rj20qe05o0sw.jpg" alt="image-20220415145205609"></p></li><li><p>安装VS Code插件</p><p><strong>Calva</strong></p></li><li><p>Project</p><p>接下来，我们学习项目版的<code>hello world</code>，即新建一个项目，新建几个文件，用文件的形式来输出<code>hello world</code>，搞定这个，我们就可以用coljure来开发项目了。</p><p>好了，执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">lein new hello-world<br></code></pre></td></tr></table></figure><p>然后用<code>VS Code</code>打开这个这个文件夹，我们就可以看到一个较完整的Clojure项目了。打开文件<code>project.clj</code>，这里是项目的一些设置项：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(<span class="hljs-name">defproject</span> hello-world <span class="hljs-string">"0.1.0-SNAPSHOT"</span><br>  <span class="hljs-symbol">:description</span> <span class="hljs-string">"FIXME: write description"</span><br>  <span class="hljs-symbol">:url</span> <span class="hljs-string">"http://example.com/FIXME"</span><br>  <span class="hljs-symbol">:license</span> &#123;<span class="hljs-symbol">:name</span> <span class="hljs-string">"EPL-2.0 OR GPL-2.0-or-later WITH Classpath-exception-2.0"</span><br>            <span class="hljs-symbol">:url</span> <span class="hljs-string">"https://www.eclipse.org/legal/epl-2.0/"</span>&#125;<br>  <span class="hljs-symbol">:dependencies</span> [[org.clojure/clojure <span class="hljs-string">"1.10.0"</span>]]<br>  <span class="hljs-symbol">:repl-options</span> &#123;<span class="hljs-symbol">:init-ns</span> hello-world.core&#125;)<br></code></pre></td></tr></table></figure><p>打开<code>src/hello-world/core.clj</code>，可看到lein已经为我们生成了一个<code>hello world</code>脚本，如下：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(<span class="hljs-name"><span class="hljs-builtin-name">ns</span></span> hello-world.core)<br><br>(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> foo<br>  <span class="hljs-string">"I don't do a whole lot."</span><br>  [x]<br>  (<span class="hljs-name">println</span> x <span class="hljs-string">"Hello, World!"</span>))<br></code></pre></td></tr></table></figure><p>里面有一个方法<code>foo</code>，下面我们在<code>project.clj</code>中添加一行<code>:main hello-world.core</code>，如下：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(<span class="hljs-name">defproject</span> hello-world <span class="hljs-string">"0.1.0-SNAPSHOT"</span><br>  <span class="hljs-symbol">:main</span> hello-world.core<br>  <span class="hljs-symbol">:description</span> <span class="hljs-string">"FIXME: write description"</span><br>  <span class="hljs-symbol">:url</span> <span class="hljs-string">"http://example.com/FIXME"</span><br>  <span class="hljs-symbol">:license</span> &#123;<span class="hljs-symbol">:name</span> <span class="hljs-string">"EPL-2.0 OR GPL-2.0-or-later WITH Classpath-exception-2.0"</span><br>            <span class="hljs-symbol">:url</span> <span class="hljs-string">"https://www.eclipse.org/legal/epl-2.0/"</span>&#125;<br>  <span class="hljs-symbol">:dependencies</span> [[org.clojure/clojure <span class="hljs-string">"1.10.0"</span>]]<br>  <span class="hljs-symbol">:repl-options</span> &#123;<span class="hljs-symbol">:init-ns</span> hello-world.core&#125;)<br></code></pre></td></tr></table></figure><p>将<code>src/hello-world/core.clj</code>略作修改：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(<span class="hljs-name"><span class="hljs-builtin-name">ns</span></span> hello-world.core)<br><br>(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> -main [&amp; args]<br>  (<span class="hljs-name">println</span> <span class="hljs-string">"Hello, World!"</span>))<br></code></pre></td></tr></table></figure><p>最后，执行：<code>lein run</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Hello, World!<br></code></pre></td></tr></table></figure><p>如果看到了这个，恭喜你开启了clojure的大门。</p></li></ul><h2 id="2-Clojure项目结构"><a href="#2-Clojure项目结构" class="headerlink" title="2. Clojure项目结构"></a>2. Clojure项目结构</h2><p>最后，我们来谈谈Clojure项目的典型项目结构。 由于Clojure代码在Java虚拟机上运行，因此Clojure中的大多数项目结构与您在java项目中找到的类似。 以下是Eclipse中Clojure项目的示例项目结构的快照。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1ethzhk1nj208b0hfwew.jpg" alt="基本语法"></p><p>关于上述程序结构，需要注意以下关键事项。</p><ul><li>demo_1 - 这是放置Clojure代码文件的包。</li><li>core.clj - 这是主要的Clojure代码文件，它将包含Clojure应用程序的代码。</li><li>Leiningen文件夹包含运行任何基于Clojure的应用程序所需的文件，如clojure-1.6.0.jar。</li><li>pom.properties文件将包含诸如groupId，artifactId和Clojure项目版本之类的信息。</li><li>project.clj文件包含有关Clojure应用程序本身的信息。 以下是项目文件内容的示例。</li></ul><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(<span class="hljs-name">defproject</span> demo-1 <span class="hljs-string">"0.1.0-SNAPSHOT"</span><br>   <span class="hljs-symbol">:description</span> <span class="hljs-string">"FIXME: write description"</span><br>   <span class="hljs-symbol">:url</span> <span class="hljs-string">"http://example.com/FIXME"</span><br>   <span class="hljs-symbol">:license</span> &#123;<br>      <span class="hljs-symbol">:name</span> <span class="hljs-string">"Eclipse Public License"</span><br>      <span class="hljs-symbol">:url</span> <span class="hljs-string">"http://www.eclipse.org/legal/epl-v10.html"</span><br>   &#125;<br>   <span class="hljs-symbol">:dependencies</span> [[org.clojure/clojure <span class="hljs-string">"1.6.0"</span>]])<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Clojure&quot;&gt;&lt;a href=&quot;#Clojure&quot; class=&quot;headerlink&quot; title=&quot;Clojure&quot;&gt;&lt;/a&gt;Clojure&lt;/h1&gt;&lt;h2 id=&quot;0-概述&quot;&gt;&lt;a href=&quot;#0-概述&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="Clojure" scheme="http://yoursite.com/categories/Clojure/"/>
    
    
      <category term="Clojure" scheme="http://yoursite.com/tags/Clojure/"/>
    
  </entry>
  
  <entry>
    <title>Workaround for oracle weblogic install error —— Cyclic dependency detected among featureset libraries</title>
    <link href="http://yoursite.com/2022/02/03/%E9%A1%B9%E7%9B%AE%E8%B8%A9%E5%9D%91/Workaround%20for%20oracle%20weblogic%20install%20error/"/>
    <id>http://yoursite.com/2022/02/03/%E9%A1%B9%E7%9B%AE%E8%B8%A9%E5%9D%91/Workaround%20for%20oracle%20weblogic%20install%20error/</id>
    <published>2022-02-03T03:26:38.000Z</published>
    <updated>2022-02-21T00:54:33.284Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Brief"><a href="#Brief" class="headerlink" title="Brief"></a>Brief</h3><p>This is the workaround for resolving errors during weblogic installation, below are details and resolving steps.</p><h3 id="1-Problem-description"><a href="#1-Problem-description" class="headerlink" title="1. Problem description"></a>1. Problem description</h3><p>When installing weblogic 12.2.1.4, we may facing the problem during progress ‘Generating Libraries’.</p><p><img src="https://s2.ax1x.com/2020/02/03/1NfFh9.png" alt=""></p><p>The error message is </p><blockquote><p>java.lang.Exception: oracle.sysman.oii.oiif.oiifb.OiifbEndIterateException:<br>com.oracle.cie.gdr.libraries.LibraryHandlerException:<br>Cyclic dependency detected among featureset libraries:<br>[C:\Oracle\Middleware\Oracle_Home\server\lib\wljmsclient.jar,<br>C:\Oracle\Middleware\Oracle_Home\server\lib\wljmxclient.jar]</p></blockquote><h3 id="2-Resolving-steps"><a href="#2-Resolving-steps" class="headerlink" title="2. Resolving steps"></a>2. Resolving steps</h3><blockquote><p>This workaround is a <strong><em>Trick</em></strong> to skip Cyclic dependency check for ‘wljmsclient.jar’ and ‘wljmxclient.jar’, after the installation completed, add back these two libraries.</p></blockquote><ol><li>Go to the install package folder.</li></ol><p><img src="https://s2.ax1x.com/2020/02/03/1Nhfqf.png" alt=""></p><ol start="2"><li>Unzip the jar file.</li></ol><p><img src="https://s2.ax1x.com/2020/02/03/1NhLMq.png" alt=""></p><ol start="3"><li>Using command line to retrieve string ‘wljmsclient.jar’, ‘wljmxclient.jar’ under the extract folder to get details about this two libraries.<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">findstr <span class="hljs-string">/s</span> <span class="hljs-string">/i</span> <span class="hljs-string">/n</span> <span class="hljs-string">"wljmsclient.jar"</span> *.*<br><br>findstr <span class="hljs-string">/s</span> <span class="hljs-string">/i</span> <span class="hljs-string">/n</span> <span class="hljs-string">"wljmxclient.jar"</span> *.*<br></code></pre></td></tr></table></figure>We can find out that the libraries are referenced in <strong><em>wls_sharedLibraries_12.2.1.4.0.xml</em></strong> under folder <strong><em>~\Disk1\stage\featuresets</em></strong></li></ol><p><img src="https://s2.ax1x.com/2020/02/03/1NhzoF.png" alt=""></p><ol start="4"><li>Go to folder <strong><em>~\Disk1\stage\featuresets</em></strong> and find file <strong><em>wls_sharedLibraries_12.2.1.4.0.xml</em></strong></li></ol><p><img src="https://s2.ax1x.com/2020/02/03/1N4VeK.png" alt=""></p><ol start="5"><li>Open the file <strong><em>wls_sharedLibraries_12.2.1.4.0.xml</em></strong> and find lines for libraries ‘wljmsclient.jar’, ‘wljmxclient.jar’.</li></ol><p><img src="https://s2.ax1x.com/2020/02/03/1N4Jw8.png" alt=""></p><ol start="6"><li>Commented out these lines in xml and save the xml.</li></ol><p><img src="https://s2.ax1x.com/2020/02/03/1N4DO0.png" alt=""></p><ol start="7"><li>Go back to folder <strong><em>~\Disk1\install</em></strong>, run the <strong><em>.ng.cmd</em></strong> script as administrator</li></ol><p><img src="https://s2.ax1x.com/2020/02/03/1N5Jj1.png" alt=""></p><p>The installation cmd is running </p><p><img src="https://s2.ax1x.com/2020/02/03/1NIS29.png" alt=""></p><ol start="8"><li>The weblogic installer will be launched and follow the installation steps. </li></ol><p><img src="https://s2.ax1x.com/2020/02/03/1NIpvR.png" alt=""></p><ol start="9"><li>Installation completed successfully.</li></ol><p><img src="https://s2.ax1x.com/2020/02/03/1NIBZV.png" alt=""></p><ol start="10"><li>Go to the target folder, find <strong><em>wls_sharedLibraries_12.2.1.4.0.xml</em></strong> under <strong><em>~/Oracle/Middleware/Oracle_Home/inventory/featuresets</em></strong></li></ol><p><img src="https://s2.ax1x.com/2020/02/03/1NoUYD.png" alt=""></p><ol start="11"><li>Open <strong><em>wls_sharedLibraries_12.2.1.4.0.xml</em></strong> and we can find out that libraries info for ‘wljmsclient.jar’, ‘wljmxclient.jar’ are not there (Because we commnet out the code when installation).</li></ol><p><img src="https://s2.ax1x.com/2020/02/03/1Nohlj.png" alt=""></p><ol start="12"><li>Add these info back.</li></ol><p><img src="https://s2.ax1x.com/2020/02/03/1NT83Q.png" alt=""></p><ol start="13"><li>Go to  <strong><em>~/Oracle/Middleware/Oracle_Home/wlserver/server/lib</em></strong></li></ol><p><img src="https://s2.ax1x.com/2020/02/03/1NTJjs.png" alt=""></p><ol start="14"><li>Compared with <strong><em>successfully installed case</em></strong>, we can know that libraries ‘wlclient.jar’ and ‘wljmxclient.jar’ are missing due to the comment out code. Add these two libraries back to folder. </li></ol><p><img src="https://s2.ax1x.com/2020/02/03/1NTz8g.png" alt=""></p><ol start="15"><li><p>I copied these two libraries from a <strong><em>successfully installed case</em></strong>, because I installed weblogic in several machines and only some of them have this  Cyclic dependency check problem, if you don’t have these two libraries in your hands, you can get them from internet.</p><blockquote><p><a href="http://find-files.com/" target="_blank" rel="noopener">http://find-files.com/</a></p></blockquote></li><li><p><strong>Done</strong>.</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Brief&quot;&gt;&lt;a href=&quot;#Brief&quot; class=&quot;headerlink&quot; title=&quot;Brief&quot;&gt;&lt;/a&gt;Brief&lt;/h3&gt;&lt;p&gt;This is the workaround for resolving errors during weblogi
      
    
    </summary>
    
    
      <category term="workaround" scheme="http://yoursite.com/categories/workaround/"/>
    
    
      <category term="Weblogic" scheme="http://yoursite.com/tags/Weblogic/"/>
    
  </entry>
  
  <entry>
    <title>9.1 B树,B+树插入删除图解</title>
    <link href="http://yoursite.com/2022/01/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/9.1%20B%E6%A0%91,B+%E6%A0%91%E6%8F%92%E5%85%A5%E5%88%A0%E9%99%A4%E5%9B%BE%E8%A7%A3/"/>
    <id>http://yoursite.com/2022/01/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/9.1%20B%E6%A0%91,B+%E6%A0%91%E6%8F%92%E5%85%A5%E5%88%A0%E9%99%A4%E5%9B%BE%E8%A7%A3/</id>
    <published>2022-01-25T04:39:39.000Z</published>
    <updated>2022-04-15T13:50:52.074Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-2-B树插入"><a href="#1-2-B树插入" class="headerlink" title="1.2 B树插入"></a>1.2 B树插入</h4><p>插入的时候，我们需要记住一个规则：<strong>判断当前结点key的个数是否小于等于m-1，如果满足，直接插入即可，如果不满足，将节点的中间的key将这个节点分为左右两部分，中间的节点放到父节点中即可。</strong></p><p>例子：在5阶B树中，结点最多有4个key,最少有2个key（注意：下面的节点统一用一个节点表示key和value）。</p><ul><li>插入18，70，50,40</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx6ak8eo65j309h02njra.jpg" alt="img"></p><ul><li>插入22</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwr5nns376j309t02t3yg.jpg" alt="img"></p><p>插入22时，发现这个节点的关键字已经大于4了，所以需要进行分裂，分裂的规则在上面已经讲了，分裂之后，如下。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwr5np2pe3j30cj05z3yp.jpg" alt="img"></p><ul><li>接着插入23，25，39</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx6akfwv3cj30g605e74l.jpg" alt="img"></p><p>分裂，得到下面的。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx6akb91a7j30fv07m0t7.jpg" alt="img"></p><p>更过的插入的过程就不多介绍了，相信有这个例子你已经知道怎么进行插入操作了。</p><h4 id="1-3-B树的删除操作"><a href="#1-3-B树的删除操作" class="headerlink" title="1.3 B树的删除操作"></a>1.3 B树的删除操作</h4><p>B树的删除操作相对于插入操作是相对复杂一些的，但是，你知道记住几种情况，一样可以很轻松的掌握的。</p><ul><li>现在有一个初始状态是下面这样的B树，然后进行删除操作。</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx6akffpjfj30kc09eaay.jpg" alt="img"></p><ul><li>删除15，这种情况是删除叶子节点的元素，如果删除之后，节点数还是大于<code>m/2</code>，这种情况只要直接删除即可。</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx6ak7xn76j30kc09zwfg.jpg" alt="img"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx6ak9ef0bj30kc097t9l.jpg" alt="img"></p><ul><li>接着，我们把22删除，这种情况的规则：22是非叶子节点，<strong>对于非叶子节点的删除，我们需要用后继key（元素）覆盖要删除的key，然后在后继key所在的子支中删除该后继key</strong>。对于删除22，需要将后继元素24移到被删除的22所在的节点。</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx6akd800oj30kc0bd3zo.jpg" alt="img"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx6ak7p8itj30kc092756.jpg" alt="img"></p><p>此时发现26所在的节点只有一个元素，小于2个（m/2），这个节点不符合要求，这时候的规则（向兄弟节点借元素）：<strong>如果删除叶子节点，如果删除元素后元素个数少于（m/2），并且它的兄弟节点的元素大于（m/2），也就是说兄弟节点的元素比最少值m/2还多，将先将父节点的元素移到该节点，然后将兄弟节点的元素再移动到父节点</strong>。这样就满足要求了。</p><p>我们看看操作过程就更加明白了。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx6akc4688j30kc092q3x.jpg" alt="img"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx6akex9s6j30kc094dgp.jpg" alt="img"></p><ul><li>接着删除28，<strong>删除叶子节点</strong>，删除后不满足要求，所以，我们需要考虑向兄弟节点借元素，但是，兄弟节点也没有多的节点（2个），借不了，怎么办呢？如果遇到这种情况，<strong>首先，还是将先将父节点的元素移到该节点，然后，将当前节点及它的兄弟节点中的key合并，形成一个新的节点</strong>。</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx6ake1o66j30kc0arab4.jpg" alt="img"></p><p>移动之后，跟兄弟节点合并。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx6akastxfj30kc09qaax.jpg" alt="img"></p><p>删除就只有上面的几种情况，根据不同的情况进行删除即可。</p><p>上面的这些介绍，相信对于B树已经有一定的了解了，接下来的一部分，我们接着讲解B+树，我相信加上B+树的对比，就更加清晰明了了。</p><h3 id="2-B-树"><a href="#2-B-树" class="headerlink" title="2 B+树"></a>2 B+树</h3><h4 id="2-1-B-树概述"><a href="#2-1-B-树概述" class="headerlink" title="2.1 B+树概述"></a>2.1 B+树概述</h4><p>B+树其实和B树是非常相似的，我们首先看看<strong>相同点</strong>。</p><ul><li>根节点至少一个元素</li><li>非根节点元素范围：m/2 &lt;= k &lt;= m-1</li></ul><p><strong>不同点</strong>。</p><ul><li>B+树有两种类型的节点：内部结点（也称索引结点）和叶子结点。内部节点就是非叶子节点，内部节点不存储数据，只存储索引，数据都存储在叶子节点。</li><li>内部结点中的key都按照从小到大的顺序排列，对于内部结点中的一个key，左树中的所有key都小于它，右子树中的key都大于等于它。叶子结点中的记录也按照key的大小排列。</li><li>每个叶子结点都存有相邻叶子结点的指针，叶子结点本身依关键字的大小自小而大顺序链接。</li><li>父节点存有右孩子的第一个元素的索引。</li></ul><p>下面我们看一个B+树的例子，感受感受它吧！</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx6ak9u8sdj30hg09yjs9.jpg" alt="img"></p><h4 id="2-2-插入操作"><a href="#2-2-插入操作" class="headerlink" title="2.2 插入操作"></a>2.2 插入操作</h4><p>对于插入操作很简单，只需要记住一个技巧即可：<strong>当节点元素数量大于m-1的时候，按中间元素分裂成左右两部分，中间元素分裂到父节点当做索引存储，但是，本身中间元素还是分裂右边这一部分的</strong>。</p><p>下面以一颗5阶B+树的插入过程为例，5阶B+树的节点最少2个元素，最多4个元素。</p><ul><li>插入5，10，15，20</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwr5nstlpxj309s04agll.jpg" alt="img"></p><ul><li>插入25，此时元素数量大于4个了，分裂</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx6akckyvaj30f206q74l.jpg" alt="img"></p><ul><li>接着插入26，30，继续分裂</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx6akbns2mj30gq0650t2.jpg" alt="img"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx6akegiwcj30j306xjrw.jpg" alt="img"></p><p>有了这几个例子，相信插入操作没什么问题了，下面接着看看删除操作。</p><h4 id="2-3-删除操作"><a href="#2-3-删除操作" class="headerlink" title="2.3 删除操作"></a>2.3 删除操作</h4><p>对于删除操作是比B树简单一些的，因为<strong>叶子节点有指针的存在，向兄弟节点借元素时，不需要通过父节点了，而是可以直接通过兄弟节移动即可（前提是兄弟节点的元素大于m/2），然后更新父节点的索引；如果兄弟节点的元素不大于m/2（兄弟节点也没有多余的元素），则将当前节点和兄弟节点合并，并且删除父节点中的key</strong>，下面我们看看具体的实例。</p><ul><li>初始状态</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx6akdj5t5j30kc06rq3l.jpg" alt="img"></p><ul><li>删除10，删除后，不满足要求，发现左边兄弟节点有多余的元素，所以去借元素，最后，修改父节点索引</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx6ak8xabpj30kc06s3z5.jpg" alt="img"></p><ul><li>删除元素5，发现不满足要求，并且发现左右兄弟节点都没有多余的元素，所以，可以选择和兄弟节点合并，最后修改父节点索引</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx6akaazg0j30kc07w3z7.jpg" alt="img"></p><ul><li>发现父节点索引也不满足条件，所以，需要做跟上面一步一样的操作</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwr5nv4474j30kc080t9g.jpg" alt="img"></p><p>这样，B+树的删除操作也就完成了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-2-B树插入&quot;&gt;&lt;a href=&quot;#1-2-B树插入&quot; class=&quot;headerlink&quot; title=&quot;1.2 B树插入&quot;&gt;&lt;/a&gt;1.2 B树插入&lt;/h4&gt;&lt;p&gt;插入的时候，我们需要记住一个规则：&lt;strong&gt;判断当前结点key的个数是否小于等于m-1
      
    
    </summary>
    
    
      <category term="Data Structure" scheme="http://yoursite.com/categories/Data-Structure/"/>
    
    
      <category term="Data Structure" scheme="http://yoursite.com/tags/Data-Structure/"/>
    
  </entry>
  
  <entry>
    <title>9.0 B树,B+树,B*树</title>
    <link href="http://yoursite.com/2022/01/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/9.0%20B%E6%A0%91,B+%E6%A0%91,B*%E6%A0%91/"/>
    <id>http://yoursite.com/2022/01/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/9.0%20B%E6%A0%91,B+%E6%A0%91,B*%E6%A0%91/</id>
    <published>2022-01-25T04:38:39.000Z</published>
    <updated>2022-02-21T00:54:33.380Z</updated>
    
    <content type="html"><![CDATA[<h1 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h1><h2 id="B-树概述"><a href="#B-树概述" class="headerlink" title="B-树概述"></a>B-树概述</h2><p>B-树,这里的 B 表示 balance( 平衡的意思),B-树是一种多路自平衡的搜索树（B树是<strong>一颗多路平衡查找树</strong>）<br>它类似普通的平衡二叉树，不同的一点是B-树允许每个节点有更多的子节点。下图是 B-树的简化图.</p><p><img src="https:////upload-images.jianshu.io/upload_images/1446087-bc023e47bc74cfa1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/800/format/webp" alt="img"></p><h2 id="为什么数据库s需要用B树，而不是用AVL树，二叉树？"><a href="#为什么数据库s需要用B树，而不是用AVL树，二叉树？" class="headerlink" title="为什么数据库s需要用B树，而不是用AVL树，二叉树？"></a>为什么数据库s需要用B树，而不是用AVL树，二叉树？</h2><p>传统用来搜索的平衡二叉树有很多，如 AVL 树，红黑树等。这些树在一般情况下查询性能非常好，但当数据非常大的时候它们就无能为力了。<strong>原因当数据量非常大时，内存不够用，大部分数据只能存放在磁盘上，只有需要的数据才加载到内存中。</strong>一般而言内存访问的时间约为 50 ns，而磁盘在 10 ms 左右。速度相差了近 5 个数量级，磁盘读取时间远远超过了数据在内存中比较的时间。这说明程序大部分时间会阻塞在磁盘 IO 上。</p><p><strong>B-树是专门为外部存储器设计的，如磁盘，它对于读取和写入大块数据有良好的性能，所以一般被用在文件系统及数据库中。</strong></p><h2 id="B树规则："><a href="#B树规则：" class="headerlink" title="B树规则："></a>B树规则：</h2><p>（1）排序方式：所有节点关键字是按递增次序排列，并遵循左小右大原则（类似AVL）。</p><p>（2）子节点数：非叶节点的子节点数&gt;1，且&lt;=M ，且M&gt;=2，空树除外。（注：M阶代表一个树节点最多有多少个查找路径，M=M路,当M=2则是2叉树,M=3则是3叉）；</p><p>（3）关键字数：枝节点的<strong>关键字数量大于等于ceil(m/2)-1个且小于等于M-1个</strong>（注：ceil()是个朝正无穷方向取整的函数 如ceil(1.1)结果为2);</p><p>（4）<strong>所有叶子节点均在同一层</strong>、叶子节点除了包含了关键字和关键字记录的指针外也有指向其子节点的指针只不过其指针地址都为null。</p><h3 id="如：（M-3）"><a href="#如：（M-3）" class="headerlink" title="如：（M=3）"></a>如：（M=3）</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx6aimasktj30hc07gmxn.jpg" alt="img"></p><h2 id="B树有如下特点"><a href="#B树有如下特点" class="headerlink" title="B树有如下特点:"></a>B树有如下特点:</h2><ol><li>所有键值分布在整颗树中（索引值和具体data都在每个节点里）；</li><li>任何一个关键字出现且只出现在一个结点中；</li><li>搜索有可能在非叶子结点结束（最好情况O(1)就能找到数据）；</li><li>在关键字全集内做一次查找,性能逼近二分查找；</li><li>非叶子结点的关键字个数=指向儿子的指针个数-1；</li><li>自动层次控制；</li></ol><h1 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h1><h2 id="B-树的定义"><a href="#B-树的定义" class="headerlink" title="B+树的定义"></a>B+树的定义</h2><p><strong>B+树是应文件系统所需而出的一种B-树的变型树。一棵m阶的B+树和m阶的B-树的差异在于：</strong></p><p>1.有n棵子树的结点中含有n个关键字，<strong>==每个关键字不保存数据，只用来索引，所有数据都保存在叶子节点==</strong>。</p><p>2.<strong>所有的叶子结点中包含了全部关键字的信息</strong>，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。</p><p>3.所有的非终端结点可以看成是索引部分，结点中仅含其子树（根结点）中的最大（或最小）关键字。通常在B+树上有两个头指针，一个指向根结点，一个指向关键字最小的叶子结点。</p><h2 id="B-树规则："><a href="#B-树规则：" class="headerlink" title="B+树规则："></a>B+树规则：</h2><p>（1）B+跟B树不同B+树的<strong>非叶子</strong>节点不保存关键字记录的指针，只进行数据索引，这样使得B+树每个<strong>非叶子</strong>节点所能保存的关键字大大增加；</p><p>（2）B+树<strong>叶子</strong>节点保存了父节点的所有关键字记录的指针，所有关键字都在叶子结点出现；所有数据地址必须要到叶子节点才能获取到。所以每次数据查询的次数都一样；</p><p>（3）B+树叶子节点的关键字从小到大有序排列，<strong>左边结尾数据都会保存右边节点开始数据的指针</strong>。</p><p>（4）<strong>非叶子节点的子节点数=关键字数（来源百度百科）</strong>（根据各种资料 这里有两种算法的实现方式，另一种为非叶节点的关键字数=子节点数-1（来源维基百科)，虽然他们数据排列结构不一样，但其原理还是一样的Mysql 的B+树是用第一种方式实现）;</p><h3 id="如：（M-3）-1"><a href="#如：（M-3）-1" class="headerlink" title="如：（M=3）"></a>如：（M=3）</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx6ailuqs1j30ft09lgmd.jpg" alt="img"></p><p>B+的搜索与B-树也基本相同，区别是B+树只有达到叶子结点才命中（B-树可以在</p><p>非叶子结点命中），其性能也等价于在关键字全集做一次二分查找；</p><h2 id="B-的特性："><a href="#B-的特性：" class="headerlink" title="B+的特性："></a>B+的特性：</h2><p>1、B+<strong>树的层级更少</strong>：相较于B树B+每个<strong>非叶子</strong>节点存储的关键字数更多，树的层级更少所以查询数据更快；</p><p>2、B+<strong>树查询速度更稳定</strong>：B+所有关键字数据地址都存在<strong>叶子</strong>节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;</p><p>3、B+<strong>树天然具备排序功能：</strong>B+树所有的<strong>叶子</strong>节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高。</p><p>4、B+<strong>树全节点遍历更快：</strong>B+树遍历整棵树只需要遍历所有的<strong>叶子</strong>节点即可，，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描。</p><p><strong>B树</strong>相对于<strong>B+树</strong>的优点是，如果经常访问的数据离根节点很近，而<strong>B树</strong>的<strong>非叶子</strong>节点本身存有关键字其数据的地址，所以这种数据检索的时候会要比<strong>B+树</strong>快。</p><h1 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B*树"></a>B*树</h1><p><strong>是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针；</strong></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx6ailnqmvj30ft09l0tk.jpg" alt="img"></p><h2 id="规则"><a href="#规则" class="headerlink" title="规则"></a><strong>规则</strong></h2><p>B*树是B+树的变种，相对于B+树他们的不同之处如下：</p><p>（1）首先是关键字个数限制问题，B+树初始化的关键字初始化个数是cei(m/2)，b<em>树的初始化个数为（cei(2/3</em>m)）</p><p>（2）B+树节点满时就会分裂，而B*树节点满时会检查兄弟节点是否满（因为每个节点都有指向兄弟的指针），如果兄弟节点未满则向兄弟节点转移关键字，如果兄弟节点已满，则从当前节点和兄弟节点各拿出1/3的数据创建一个新的节点出来；</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a><strong>特点</strong></h2><p>在B+树的基础上因其初始化的容量变大，使得节点空间使用率更高，而又存有兄弟节点的指针，可以向兄弟节点转移关键字的特性使得B*树额分解次数变得更少；</p><h1 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h1><p><strong>B-树：</strong></p><p>多路搜索树，每个结点存储M/2到M个关键字，非叶子结点存储指向关键字范围的子结点；</p><p>所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中；</p><p><strong>B+树：</strong></p><p>在B-树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点中出现，非叶子结点作为叶子结点的索引；</p><p>B+树总是到叶子结点才命中；</p><p><strong>B*树：</strong></p><p>在B+树基础上，为非叶子结点也增加链表指针，将结点的最低利用率从1/2提高到2/3；</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;B树&quot;&gt;&lt;a href=&quot;#B树&quot; class=&quot;headerlink&quot; title=&quot;B树&quot;&gt;&lt;/a&gt;B树&lt;/h1&gt;&lt;h2 id=&quot;B-树概述&quot;&gt;&lt;a href=&quot;#B-树概述&quot; class=&quot;headerlink&quot; title=&quot;B-树概述&quot;&gt;&lt;/a&gt;B-树概
      
    
    </summary>
    
    
      <category term="Data Structure" scheme="http://yoursite.com/categories/Data-Structure/"/>
    
    
      <category term="Data Structure" scheme="http://yoursite.com/tags/Data-Structure/"/>
    
  </entry>
  
  <entry>
    <title>8.2.哈希冲突与解决(拉链法,线性探测法)</title>
    <link href="http://yoursite.com/2022/01/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/8.2.%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E4%B8%8E%E8%A7%A3%E5%86%B3(%E6%8B%89%E9%93%BE%E6%B3%95,%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B%E6%B3%95)/"/>
    <id>http://yoursite.com/2022/01/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/8.2.%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E4%B8%8E%E8%A7%A3%E5%86%B3(%E6%8B%89%E9%93%BE%E6%B3%95,%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B%E6%B3%95)/</id>
    <published>2022-01-22T14:38:39.000Z</published>
    <updated>2022-02-21T00:54:33.379Z</updated>
    
    <content type="html"><![CDATA[<h1 id="哈希冲突与解决-拉链法-线性探测法"><a href="#哈希冲突与解决-拉链法-线性探测法" class="headerlink" title="哈希冲突与解决(拉链法,线性探测法)"></a>哈希冲突与解决(拉链法,线性探测法)</h1><p>参考：<a href="https://blog.csdn.net/u012124438/article/details/78230478" target="_blank" rel="noopener">https://blog.csdn.net/u012124438/article/details/78230478</a></p><h2 id="1-线性探测-vs-拉链法"><a href="#1-线性探测-vs-拉链法" class="headerlink" title="1. 线性探测 vs 拉链法"></a>1. 线性探测 vs 拉链法</h2><p>开放寻址法和链表法。这两种冲突解决办法在实际的软件开发中都非常常用。比如，LinkedHashMap 就采用了链表法解决冲突，ThreadLocalMap 是通过线性探测的开放寻址法来解决冲突。那你知道，这两种冲突解决方法各有什么优势和劣势，又各自适用哪些场景吗？</p><p><strong>（1）开放寻址法优缺点</strong></p><ul><li>开放寻址法优点：<ul><li>散列表中的数据都存储在数组中，可以有效地利用 CPU 缓存加快查询速度。</li><li>数组实现的散列表，序列化起来比较简单。链表法包含指针，序列化起来就没那么容易。你可不要小看序列化，很多场合都会用到的。</li></ul></li><li>开放寻址法缺点：<ul><li>用开放寻址法解决冲突的散列表，删除数据的时候比较麻烦，需要特殊标记已经删除掉的数据。</li><li>在开放寻址法中，所有的数据都存储在一个数组中，比起链表法来说，冲突的代价更高。</li><li>装载因子的上限不能太大，导致这种方法比链表法更浪费内存空间。</li></ul></li></ul><p><strong>总结：</strong> <strong>当数据量比较小、装载因子小的时候，适合采用开放寻址法。</strong>这也是 ThreadLocalMap 使用开放寻址法解决散列冲突的原因。</p><p><strong>（2）拉链法优缺点</strong></p><ul><li>拉链法优点：<ul><li>首先，链表法对内存的利用率比开放寻址法要高。因为链表结点可以在需要的时候再创建，并不需要像开放寻址法那样事先申请好。</li><li>链表法比起开放寻址法，对大装载因子的容忍度更高。开放寻址法只能适用装载因子小于 1 的情况。接近 1 时，就可能会有大量的散列冲突，导致大量的探测、再散列等，性能会下降很多。但是对于链表法来说，只要散列函数的值随机均匀，即便装载因子变成 10，也就是链表的长度变长了而已，虽然查找效率有所下降，但是比起顺序查找还是快很多。</li><li>可以将链表改造为其他高效的动态数据结构，比如跳表、红黑树。这样，即便出现散列冲突，极端情况下，所有的数据都散列到同一个桶内，那最终退化成的散列表的查找时间也只不过是 O(logn)。</li></ul></li><li>拉链法缺点：<ul><li>链表因为要存储指针，所以对于比较小的对象的存储，是比较消耗内存的，还有可能会让内存的消耗翻倍。但如果我们存储的是大对象，此时存储对象远远大于指针大小（4 byte 或 8 byte），那链表中指针的内存消耗在大对象面前就可以忽略了。</li><li>因为链表中的结点是零散分布在内存中的，不是连续的，所以对 CPU 缓存是不友好的，这方面对于执行效率也有一定的影响。</li></ul></li></ul><p><strong>总结：</strong> <strong>基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列表。</strong>而且，比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;哈希冲突与解决-拉链法-线性探测法&quot;&gt;&lt;a href=&quot;#哈希冲突与解决-拉链法-线性探测法&quot; class=&quot;headerlink&quot; title=&quot;哈希冲突与解决(拉链法,线性探测法)&quot;&gt;&lt;/a&gt;哈希冲突与解决(拉链法,线性探测法)&lt;/h1&gt;&lt;p&gt;参考：&lt;a hr
      
    
    </summary>
    
    
      <category term="Data Structure" scheme="http://yoursite.com/categories/Data-Structure/"/>
    
    
      <category term="Data Structure" scheme="http://yoursite.com/tags/Data-Structure/"/>
    
  </entry>
  
  <entry>
    <title>8.1.哈希表(散列表)</title>
    <link href="http://yoursite.com/2022/01/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/8.1.%E5%93%88%E5%B8%8C%E8%A1%A8(%E6%95%A3%E5%88%97%E8%A1%A8)/"/>
    <id>http://yoursite.com/2022/01/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/8.1.%E5%93%88%E5%B8%8C%E8%A1%A8(%E6%95%A3%E5%88%97%E8%A1%A8)/</id>
    <published>2022-01-21T14:37:39.000Z</published>
    <updated>2022-02-21T01:12:43.397Z</updated>
    
    <content type="html"><![CDATA[<h1 id="散列表-哈希表"><a href="#散列表-哈希表" class="headerlink" title="散列表(哈希表)"></a><strong>散列表(哈希表)</strong></h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h2><p>散列表也叫哈希表，是一种通过键值对直接访问数据的机构。<strong>借助散列函数对数组进行扩展，利用的是数组支持按照下标随机访问元素的特性。</strong>散列表的实现原理正是映射的原理，通过设定的一个关键字和一个映射函数，就可以直接获得访问数据的地址，实现O(1)的数据访问效率。在映射的过程中，事先设定的函数就是一个映射表，也可以称作散列函数或者哈希函数。散列函数有 MD5、SHA、CRC 等哈希算法。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwmuu8vpaxj31200eodh1.jpg" alt="image-20211121163245049"></p><p>散列表的实现最关键的就是散列函数的定义和选择。</p><h2 id="2-散列函数"><a href="#2-散列函数" class="headerlink" title="2. 散列函数"></a>2. 散列函数</h2><p>什么才是好的散列函数：</p><ul><li><strong>散列函数的设计不能太复杂</strong>。过于复杂的散列函数，势必会占用更多 CPU，也就间接的影响到散列表的性能。</li><li><strong>散列函数生成的值要尽可能随机并且均匀分布</strong>。这样才能避免或者最小化散列冲突，而且即便出现冲突，散列到每个槽里的数据也会比较平均，不会出现某个槽内数据特别多的情况。</li></ul><p><strong>一般常用的有以下几种散列函数：</strong></p><h3 id="2-1-直接定址法"><a href="#2-1-直接定址法" class="headerlink" title="2.1 直接定址法"></a>2.1 直接定址法</h3><blockquote><p>取关键字或关键字的某个线性函数值为散列地址。</p><p>关键码本身和地址之间存在某个线性函数关系时，散列函数取为关键码的线性函数，即：<code>hash(key) = a * key + b</code>（a、b 均为常数）。</p><p>这样的散列函数优点就是简单、均匀，也不会产生冲突，但问题是这需要事先知道关键字的分布情况，适合査找表较小且连续的情况。由于这样的限制，<strong>在现实应用中虽然简单，但却并不常用</strong>。</p></blockquote><h3 id="2-2-余数法"><a href="#2-2-余数法" class="headerlink" title="2.2 余数法"></a>2.2 <strong>余数法</strong></h3><blockquote><p>通过选择适当的正整数 p，按计算公式 <code>hash(K) = K % p</code> 来计算关键码 K 的散列地址。这种方法计算最简单，也不需根据全部关键码的分布情况研究如何从中析取数据，<strong>最常用</strong>。这种方式也可以在用过其他方法后再使用。该函数对 p 的选择很重要，一般取素数或者直接用 n。</p></blockquote><h3 id="2-3-平方取中法"><a href="#2-3-平方取中法" class="headerlink" title="2.3 平方取中法"></a>2.3 平方取中法</h3><blockquote><p>当无法确定关键字里哪几位的分布相对比较均匀时，可以先求出关键字的平方值，然后按需要取平方值的中间几位作为散列地址。这是因为：计算平方之后的中间几位和关键字中的每一位都相关，所以不同的关键字会以较高的概率产生不同的散列地址。</p><p>将关键码 K 平方，取 K^2 中间几位作为其散列地址 hash(K) 的值。</p><p>假如有以下关键字序列 {421，423，436}，平方之后的结果为 {177241，178929，190096}，那么可以取 {72，89，00} 作为 Hash 地址。</p></blockquote><h3 id="2-4-随机数法"><a href="#2-4-随机数法" class="headerlink" title="2.4 随机数法"></a>2.4 随机数法</h3><blockquote><p>采用随机函数作为散列函数 <code>hash(Key) = random(Key)</code>，其中 random 为随机函数。<strong>当关键码长度不等时，采用该方法较恰当。</strong></p></blockquote><h3 id="2-5-数字分析法："><a href="#2-5-数字分析法：" class="headerlink" title="2.5 数字分析法："></a><strong>2.5 数字分析法</strong>：</h3><blockquote><p>通过对数据的分析，发现数据中冲突较少的部分，并构造散列地址。例如同学们的学号，通常同一届学生的学号，其中前面的部分差别不太大，所以用后面的部分来构造散列地址。 </p></blockquote><h2 id="3-散列冲突"><a href="#3-散列冲突" class="headerlink" title="3. 散列冲突"></a><strong>3. 散列冲突</strong></h2><p>确定好散列函数之后，通过某个<code>key</code>值的确会得到一个唯一的<code>value</code>地址。但是却会出现一些特殊情况。<strong>即通过不同的<code>key</code>值可能会访问到同一个地址，这个现象称之为冲突。</strong></p><p>冲突在发生之后，当在对不同的<code>key</code>值进行操作时会使得造成相同地址的数据发生覆盖或者丢失，是非常危险的。所以在设计散列表往往还需要采用冲突解决的办法。</p><p>常用的冲突处理方式有很多，常用的包括以下几种：</p><h3 id="3-1-开放地址法（也叫开放寻址法）："><a href="#3-1-开放地址法（也叫开放寻址法）：" class="headerlink" title="3.1 开放地址法（也叫开放寻址法）："></a><strong>3.1 开放地址法</strong>（也叫开放寻址法）：</h3><p>如果出现了散列冲突，就重新探测一个空闲位置。根据重新探测的方式，又可以分为线性探测、二次探测、双重哈希三种。</p><ul><li><strong>线性探测(Linear Probing)</strong>：从发生冲突位置依次往后查找空闲位置。线性探测会导致数据集中到某一块区域。</li><li><strong>二次探测(Quadratic probing)</strong>：如果说线性探测每次探测的步长是 1，即线性探测的下标序列就是 hash(key) + 0，hash(key) + 1，hash(key) + 2……。而二次探测探测的步长就变成了原来的“二次方”，也就是说，它探测的下标序列就是 hash(key) + 02，hash(key) + 12，hash(key) + 22……。</li><li><strong>双重哈希(Double hashing)</strong>：前面的两种探测方式都只使用一个散列函数，而双重哈希则会使用一组散列函数 hash1(key)，hash2(key)，hash3(key)……我们先用第一个散列函数，如果计算得到的存储位置已经被占用，再用第二个散列函数，依次类推，直到找到空闲的存储位置。这种方式的缺点是时间增加了。 </li></ul><h3 id="3-2-链地址法："><a href="#3-2-链地址法：" class="headerlink" title="3.2 链地址法："></a><strong>3.2 链地址法</strong>：</h3><p>链地址法其实就是对Key通过哈希之后落在同一个地址上的值，做一个链表。使用链表将所有散列值相同的元素我们都放到相同槽位对应的链表中。当然，这个链表可能为简单链表，也可能是红黑树，如 HahMap。</p><p>==<strong>目前比较常用的冲突解决方法是链地址法，一般可以通过数组和链表的结合达到冲突数据缓存的目的</strong>==。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwmuussdnij314k0l640l.jpg" alt="image-20211121163316703"></p><p>左侧数组的每个成员包括一个指针，指向一个链表的头。每发生一个冲突的数据，就将该数据作为链表的节点链接到链表尾部。这样一来，就可以保证冲突的数据能够区分并顺利访问。</p><p>考虑到链表过长造成的问题，还可以<strong>使用红黑树替换链表进行冲突数据的处理操作，来提高散列表的查询稳定性</strong>。</p><h3 id="3-3-公共溢出区："><a href="#3-3-公共溢出区：" class="headerlink" title="3.3 公共溢出区："></a><strong>3.3 公共溢出区</strong>：</h3><p>这种方式是建立一个公共溢出区，当地址存在冲突时，把新的地址放在公共溢出区里。很少用。</p><p>不管采用哪种探测方法，当散列表中空闲位置不多的时候，散列冲突的概率就会大大提高。为了尽可能保证散列表的操作效率，一般情况下，我们会尽可能保证散列表中有一定比例的空闲槽位。我们用装载因子来表示空位的多少。<strong>装载因子（load factor）</strong>的计算公式是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">散列表的装载因子 &#x3D; 表中的元素个数 &#x2F; 散列表的长度<br></code></pre></td></tr></table></figure><p>实例参考： <a href="https://www.jianshu.com/p/a89e9487a06c" target="_blank" rel="noopener">https://www.jianshu.com/p/a89e9487a06c</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;散列表-哈希表&quot;&gt;&lt;a href=&quot;#散列表-哈希表&quot; class=&quot;headerlink&quot; title=&quot;散列表(哈希表)&quot;&gt;&lt;/a&gt;&lt;strong&gt;散列表(哈希表)&lt;/strong&gt;&lt;/h1&gt;&lt;h2 id=&quot;1-定义&quot;&gt;&lt;a href=&quot;#1-定义&quot; clas
      
    
    </summary>
    
    
      <category term="Data Structure" scheme="http://yoursite.com/categories/Data-Structure/"/>
    
    
      <category term="Data Structure" scheme="http://yoursite.com/tags/Data-Structure/"/>
    
  </entry>
  
  <entry>
    <title>7.6.图的最短路径(Djkstra, Floyd)</title>
    <link href="http://yoursite.com/2022/01/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/7.6.%E5%9B%BE%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84(Djkstra,%20Floyd)/"/>
    <id>http://yoursite.com/2022/01/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/7.6.%E5%9B%BE%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84(Djkstra,%20Floyd)/</id>
    <published>2022-01-20T14:36:39.000Z</published>
    <updated>2022-02-21T00:54:33.379Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最短路径-Djkstra-Floyd"><a href="#最短路径-Djkstra-Floyd" class="headerlink" title="最短路径(Djkstra, Floyd)"></a>最短路径(Djkstra, Floyd)</h1><h2 id="迪杰斯特拉算法介绍"><a href="#迪杰斯特拉算法介绍" class="headerlink" title="迪杰斯特拉算法介绍"></a><strong>迪杰斯特拉算法介绍</strong></h2><p>Dijkstra算法功能：给出<strong>加权连通图</strong>中一个顶点，称之为起点，找出起点到其它所有顶点之间的最短距离。</p><p>它的主要特点是以起始点为中心向外层层扩展(BFS广度优先搜索思想)，直到扩展到终点为止。</p><p><strong>基本思想</strong></p><p>   通过Dijkstra计算图G中的最短路径时，需要指定起点s(即从顶点s开始计算)。</p><p>   此外，引进两个集合S和U。S的作用是记录已求出最短路径的顶点(以及相应的最短路径长度)，而U则是记录还未求出最短路径的顶点(以及该顶点到起点s的距离)。</p><p>   初始时，S中只有起点s；U中是除s之外的顶点，并且U中顶点的路径是”起点s到该顶点的路径”。然后，从U中找出路径最短的顶点，并将其加入到S中；接着，更新U中的顶点和顶点对应的路径。 然后，再从U中找出路径最短的顶点，并将其加入到S中；接着，更新U中的顶点和顶点对应的路径。 … 重复该操作，直到遍历完所有顶点。</p><p><strong>操作步骤</strong></p><p><strong>(1)</strong> 初始时，S只包含起点s；U包含除s外的其他顶点，且U中顶点的距离为”起点s到该顶点的距离”[例如，U中顶点v的距离为(s,v)的长度，然后s和v不相邻，则v的距离为∞]。</p><p><strong>(2)</strong> 从U中选出”距离最短的顶点k”，并将顶点k加入到S中；同时，从U中移除顶点k。</p><p><strong>(3)</strong> 更新U中各个顶点到起点s的距离。之所以更新U中顶点的距离，是由于上一步中确定了k是求出最短路径的顶点，从而可以利用k来更新其它顶点的距离；例如，(s,v)的距离可能大于(s,k)+(k,v)的距离。</p><p><strong>(4)</strong> 重复步骤(2)和(3)，直到遍历完所有顶点。</p><p>单纯的看上面的理论可能比较难以理解，下面通过实例来对该算法进行说明。</p><h2 id="迪杰斯特拉算法图解"><a href="#迪杰斯特拉算法图解" class="headerlink" title="迪杰斯特拉算法图解"></a><strong>迪杰斯特拉算法图解</strong></h2><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/dijkstra/01.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwo7enm7kmj30aj07et8v.jpg" alt="img"></a></p><p>以上图G4为例，来对迪杰斯特拉进行算法演示(以第4个顶点D为起点)。(B的权重有错误)</p><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/dijkstra/02.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwo7eo046pj30jz184jw8.jpg" alt="img"></a></p><p><strong>初始状态</strong>：S是已计算出最短路径的顶点集合，U是未计算除最短路径的顶点的集合！<br><strong>第1步</strong>：将顶点D加入到S中。<br>  此时，S={D(0)}, U={A(∞),B(∞),C(3),E(4),F(∞),G(∞)}。   注:C(3)表示C到起点D的距离是3。</p><p><strong>第2步</strong>：将顶点C加入到S中。<br>  上一步操作之后，U中顶点C到起点D的距离最短；因此，将C加入到S中，同时更新U中顶点的距离。以顶点F为例，之前F到D的距离为∞；但是将C加入到S之后，F到D的距离为9=(F,C)+(C,D)。<br>  此时，S={D(0),C(3)}, U={A(∞),B(23),E(4),F(9),G(∞)}。</p><p><strong>第3步</strong>：将顶点E加入到S中。<br>  上一步操作之后，U中顶点E到起点D的距离最短；因此，将E加入到S中，同时更新U中顶点的距离。还是以顶点F为例，之前F到D的距离为9；但是将E加入到S之后，F到D的距离为6=(F,E)+(E,D)。<br>  此时，S={D(0),C(3),E(4)}, U={A(∞),B(23),F(6),G(12)}。</p><p><strong>第4步</strong>：将顶点F加入到S中。<br>  此时，S={D(0),C(3),E(4),F(6)}, U={A(22),B(13),G(12)}。</p><p><strong>第5步</strong>：将顶点G加入到S中。<br>  此时，S={D(0),C(3),E(4),F(6),G(12)}, U={A(22),B(13)}。</p><p><strong>第6步</strong>：将顶点B加入到S中。<br>  此时，S={D(0),C(3),E(4),F(6),G(12),B(13)}, U={A(22)}。</p><p><strong>第7步</strong>：将顶点A加入到S中。<br>  此时，S={D(0),C(3),E(4),F(6),G(12),B(13),A(22)}。</p><p>此时，起点D到各个顶点的最短距离就计算出来了：<strong>A(22) B(13) C(3) D(0) E(4) F(6) G(12)</strong>。</p><h2 id="迪杰斯特拉算法的代码说明"><a href="#迪杰斯特拉算法的代码说明" class="headerlink" title="迪杰斯特拉算法的代码说明"></a><strong>迪杰斯特拉算法的代码说明</strong></h2><h3 id="1-基本定义"><a href="#1-基本定义" class="headerlink" title="1. 基本定义"></a><strong>1. 基本定义</strong></h3><p>MatrixUDG是邻接矩阵对应的结构体。mVexs用于保存顶点，mEdgNum用于保存边数，mMatrix则是用于保存矩阵信息的二维数组。例如，mMatrix[i][j]=1，则表示”顶点i(即mVexs[i])”和”顶点j(即mVexs[j])”是邻接点；mMatrix[i][j]=0，则表示它们不是邻接点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MatrixUDG</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> mEdgNum;        <span class="hljs-comment">// 边的数量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">char</span>[] mVexs;       <span class="hljs-comment">// 顶点集合</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[][] mMatrix;    <span class="hljs-comment">// 邻接矩阵</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> INF = Integer.MAX_VALUE;   <span class="hljs-comment">// 最大值</span><br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-迪杰斯特拉算法"><a href="#2-迪杰斯特拉算法" class="headerlink" title="2. 迪杰斯特拉算法"></a><strong>2. 迪杰斯特拉算法</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*<br> * Dijkstra最短路径。<br> * 即，统计图中"顶点vs"到其它各个顶点的最短路径。<br> *<br> * 参数说明：<br> *       vs -- 起始顶点(start vertex)。即计算"顶点vs"到其它顶点的最短路径。<br> *     prev -- 前驱顶点数组。即，prev[i]的值是"顶点vs"到"顶点i"的最短路径所经历的全部顶点中，位于"顶点i"之前的那个顶点。<br> *     dist -- 长度数组。即，dist[i]是"顶点vs"到"顶点i"的最短路径的长度。<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-keyword">int</span> vs, <span class="hljs-keyword">int</span>[] prev, <span class="hljs-keyword">int</span>[] dist)</span> </span>&#123;<br>    <span class="hljs-comment">// flag[i]=true表示"顶点vs"到"顶点i"的最短路径已成功获取</span><br>    <span class="hljs-keyword">boolean</span>[] flag = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[mVexs.length];<br><br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mVexs.length; i++) &#123;<br>        flag[i] = <span class="hljs-keyword">false</span>;          <span class="hljs-comment">// 顶点i的最短路径还没获取到。</span><br>        prev[i] = <span class="hljs-number">0</span>;              <span class="hljs-comment">// 顶点i的前驱顶点为0。</span><br>        dist[i] = mMatrix[vs][i];  <span class="hljs-comment">// 顶点i的最短路径为"顶点vs"到"顶点i"的权。</span><br>    &#125;<br><br>    <span class="hljs-comment">// 对"顶点vs"自身进行初始化</span><br>    flag[vs] = <span class="hljs-keyword">true</span>;<br>    dist[vs] = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 遍历mVexs.length-1次；每次找出一个顶点的最短路径。</span><br>    <span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; mVexs.length; i++) &#123;<br>        <span class="hljs-comment">// 寻找当前最小的路径；</span><br>        <span class="hljs-comment">// 即，在未获取最短路径的顶点中，找到离vs最近的顶点(k)。</span><br>        <span class="hljs-keyword">int</span> min = INF;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; mVexs.length; j++) &#123;<br>            <span class="hljs-keyword">if</span> (flag[j]==<span class="hljs-keyword">false</span> &amp;&amp; dist[j]&lt;min) &#123;<br>                min = dist[j];<br>                k = j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 标记"顶点k"为已经获取到最短路径</span><br>        flag[k] = <span class="hljs-keyword">true</span>;<br><br>        <span class="hljs-comment">// 修正当前最短路径和前驱顶点</span><br>        <span class="hljs-comment">// 即，当已经"顶点k的最短路径"之后，更新"未获取最短路径的顶点的最短路径和前驱顶点"。</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; mVexs.length; j++) &#123;<br>            <span class="hljs-keyword">int</span> tmp = (mMatrix[k][j]==INF ? INF : (min + mMatrix[k][j]));<br>            <span class="hljs-keyword">if</span> (flag[j]==<span class="hljs-keyword">false</span> &amp;&amp; (tmp&lt;dist[j]) ) &#123;<br>                dist[j] = tmp;<br>                prev[j] = k;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 打印dijkstra最短路径的结果</span><br>    System.out.printf(<span class="hljs-string">"dijkstra(%c): \n"</span>, mVexs[vs]);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i &lt; mVexs.length; i++)<br>        System.out.printf(<span class="hljs-string">"  shortest(%c, %c)=%d\n"</span>, mVexs[vs], mVexs[i], dist[i]);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="弗洛伊德算法介绍"><a href="#弗洛伊德算法介绍" class="headerlink" title="弗洛伊德算法介绍"></a><strong>弗洛伊德算法介绍</strong></h2><p><strong>基本思想</strong></p><p>   通过Floyd计算图G=(V,E)中各个顶点的最短路径时，需要引入一个矩阵S，矩阵S中的元素a[i][j]表示顶点i(第i个顶点)到顶点j(第j个顶点)的距离。</p><p>   假设图G中顶点个数为N，则需要对矩阵S进行N次更新。初始时，矩阵S中顶点a[i][j]的距离为顶点i到顶点j的权值；如果i和j不相邻，则a[i][j]=∞。 接下来开始，对矩阵S进行N次更新。第1次更新时，如果”a[i][j]的距离” &gt; “a[i][0]+a[0][j]”(a[i][0]+a[0][j]表示”i与j之间经过第1个顶点的距离”)，则更新a[i][j]为”a[i][0]+a[0][j]”。 同理，第k次更新时，如果”a[i][j]的距离” &gt; “a[i][k]+a[k][j]”，则更新a[i][j]为”a[i][k]+a[k][j]”。更新N次之后，操作完成！</p><p>   单纯的看上面的理论可能比较难以理解，下面通过实例来对该算法进行说明。</p><p>   <strong>与Djkstra比较：</strong>最后的邻接矩阵包含以任意顶点喂起点的最短路径。</p><h2 id="弗洛伊德算法图解"><a href="#弗洛伊德算法图解" class="headerlink" title="弗洛伊德算法图解"></a><strong>弗洛伊德算法图解</strong></h2><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/floyd/01.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwo7sofmklj30rc08fmy6.jpg" alt="img"></a></p><p>以上图G4为例，来对弗洛伊德进行算法演示。</p><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/floyd/02.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwo7sqfkq5j30rv1r17d3.jpg" alt="img"></a></p><p><strong>初始状态</strong>：S是记录各个顶点间最短路径的矩阵。<br><strong>第1步</strong>：初始化S。<br>  矩阵S中顶点a[i][j]的距离为顶点i到顶点j的权值；如果i和j不相邻，则a[i][j]=∞。实际上，就是将图的原始矩阵复制到S中。<br>  注:a[i][j]表示矩阵S中顶点i(第i个顶点)到顶点j(第j个顶点)的距离。</p><p><strong>第2步</strong>：以顶点A(第1个顶点)为中介点，若a[i][j] &gt; a[i][0]+a[0][j]，则设置a[i][j]=a[i][0]+a[0][j]。<br>  以顶点a[1]<a href="http://i.cnblogs.com/即顶点B和顶点G之间的距离为例" target="_blank" rel="noopener">6</a>，上一步操作之后，a[1][6]=∞；而将A作为中介点时，(B,A)=12，(A,G)=14，因此B和G之间的距离可以更新为26。</p><p>同理，依次将顶点B,C,D,E,F,G作为中介点，并更新a[i][j]的大小。</p><h2 id="弗洛伊德算法的代码说明"><a href="#弗洛伊德算法的代码说明" class="headerlink" title="弗洛伊德算法的代码说明"></a><strong>弗洛伊德算法的代码说明</strong></h2><h3 id="1-基本定义-1"><a href="#1-基本定义-1" class="headerlink" title="1. 基本定义"></a><strong>1. 基本定义</strong></h3><p>MatrixUDG是邻接矩阵对应的结构体。mVexs用于保存顶点，mEdgNum用于保存边数，mMatrix则是用于保存矩阵信息的二维数组。例如，mMatrix[i][j]=1，则表示”顶点i(即mVexs[i])”和”顶点j(即mVexs[j])”是邻接点；mMatrix[i][j]=0，则表示它们不是邻接点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MatrixUDG</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> mEdgNum;        <span class="hljs-comment">// 边的数量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">char</span>[] mVexs;       <span class="hljs-comment">// 顶点集合</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[][] mMatrix;    <span class="hljs-comment">// 邻接矩阵</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> INF = Integer.MAX_VALUE;   <span class="hljs-comment">// 最大值</span><br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-弗洛伊德算法"><a href="#2-弗洛伊德算法" class="headerlink" title="2. 弗洛伊德算法"></a><strong>2. 弗洛伊德算法</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*<br> * floyd最短路径。<br> * 即，统计图中各个顶点间的最短路径。<br> *<br> * 参数说明：<br> *     path -- 路径。path[i][j]=k表示，"顶点i"到"顶点j"的最短路径会经过顶点k。<br> *     dist -- 长度数组。即，dist[i][j]=sum表示，"顶点i"到"顶点j"的最短路径的长度是sum。<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">floyd</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] path, <span class="hljs-keyword">int</span>[][] dist)</span> </span>&#123;<br><br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mVexs.length; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; mVexs.length; j++) &#123;<br>            dist[i][j] = mMatrix[i][j];    <span class="hljs-comment">// "顶点i"到"顶点j"的路径长度为"i到j的权值"。</span><br>            path[i][j] = j;                <span class="hljs-comment">// "顶点i"到"顶点j"的最短路径是经过顶点j。</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 计算最短路径</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; mVexs.length; k++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mVexs.length; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; mVexs.length; j++) &#123;<br><br>                <span class="hljs-comment">// 如果经过下标为k顶点路径比原两点间路径更短，则更新dist[i][j]和path[i][j]</span><br>                <span class="hljs-keyword">int</span> tmp = (dist[i][k]==INF || dist[k][j]==INF) ? INF : (dist[i][k] + dist[k][j]);<br>                <span class="hljs-keyword">if</span> (dist[i][j] &gt; tmp) &#123;<br>                    <span class="hljs-comment">// "i到j最短路径"对应的值设，为更小的一个(即经过k)</span><br>                    dist[i][j] = tmp;<br>                    <span class="hljs-comment">// "i到j最短路径"对应的路径，经过k</span><br>                    path[i][j] = path[i][k];<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 打印floyd最短路径的结果</span><br>    System.out.printf(<span class="hljs-string">"floyd: \n"</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mVexs.length; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; mVexs.length; j++)<br>            System.out.printf(<span class="hljs-string">"%2d  "</span>, dist[i][j]);<br>        System.out.printf(<span class="hljs-string">"\n"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;最短路径-Djkstra-Floyd&quot;&gt;&lt;a href=&quot;#最短路径-Djkstra-Floyd&quot; class=&quot;headerlink&quot; title=&quot;最短路径(Djkstra, Floyd)&quot;&gt;&lt;/a&gt;最短路径(Djkstra, Floyd)&lt;/h1&gt;&lt;h2 i
      
    
    </summary>
    
    
      <category term="Data Structure" scheme="http://yoursite.com/categories/Data-Structure/"/>
    
    
      <category term="Data Structure" scheme="http://yoursite.com/tags/Data-Structure/"/>
    
  </entry>
  
  <entry>
    <title>7.5.图的最小生成树(Prime, Kruskal)</title>
    <link href="http://yoursite.com/2022/01/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/7.5.%E5%9B%BE%E7%9A%84%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91(Prime,%20Kruskal)/"/>
    <id>http://yoursite.com/2022/01/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/7.5.%E5%9B%BE%E7%9A%84%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91(Prime,%20Kruskal)/</id>
    <published>2022-01-17T14:35:39.000Z</published>
    <updated>2022-02-21T01:12:43.398Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最小生成树-Prime-Kruskal"><a href="#最小生成树-Prime-Kruskal" class="headerlink" title="最小生成树(Prime, Kruskal)"></a>最小生成树(Prime, Kruskal)</h1><h2 id="最小生成树概念"><a href="#最小生成树概念" class="headerlink" title="最小生成树概念"></a><strong>最小生成树概念</strong></h2><p>在含有n个顶点的连通图中选择n-1条边，构成一棵极小连通子图，并使该连通子图中n-1条边上权值之和达到最小，则称其为连通网的最小生成树。<br><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/kruskal/01.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwn1aw8x2lj30aj07et8v.jpg" alt="img"></a></p><p>例如，对于如上图G4所示的连通网可以有多棵权值总和不相同的生成树。</p><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/kruskal/02.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwn1awqlhsj30vj07et9l.jpg" alt="img"></a></p><h1 id="克鲁斯卡尔-Kruskal-算法"><a href="#克鲁斯卡尔-Kruskal-算法" class="headerlink" title="克鲁斯卡尔(Kruskal)算法"></a><strong>克鲁斯卡尔(Kruskal)算法</strong></h1><p>克鲁斯卡尔(Kruskal)算法，是用来求加权连通图的最小生成树的算法。</p><p><strong>基本思想</strong>：按照权值从小到大的顺序选择n-1条边，并保证这n-1条边不构成回路。<br><strong>具体做法</strong>：首先构造一个只含n个顶点的森林，然后依权值从小到大从连通网中选择边加入到森林中，并使森林中不产生回路，直至森林变成一棵树为止。</p><h2 id="克鲁斯卡尔算法图解"><a href="#克鲁斯卡尔算法图解" class="headerlink" title="克鲁斯卡尔算法图解"></a><strong>克鲁斯卡尔算法图解</strong></h2><p>以上图G4为例，来对克鲁斯卡尔进行演示(假设，用数组R保存最小生成树结果)。</p><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/kruskal/03.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwn1rekeu5j30do11u0vb.jpg" alt="img"></a></p><p><strong>第1步</strong>：将边&lt;E,F&gt;加入R中。<br>  边&lt;E,F&gt;的权值最小，因此将它加入到最小生成树结果R中。<br><strong>第2步</strong>：将边&lt;C,D&gt;加入R中。<br>  上一步操作之后，边&lt;C,D&gt;的权值最小，因此将它加入到最小生成树结果R中。<br><strong>第3步</strong>：将边&lt;D,E&gt;加入R中。<br>  上一步操作之后，边&lt;D,E&gt;的权值最小，因此将它加入到最小生成树结果R中。<br><strong>第4步</strong>：将边&lt;B,F&gt;加入R中。<br>  上一步操作之后，边&lt;C,E&gt;的权值最小，但&lt;C,E&gt;会和已有的边构成回路；因此，跳过边&lt;C,E&gt;。同理，跳过边&lt;C,F&gt;。将边&lt;B,F&gt;加入到最小生成树结果R中。<br><strong>第5步</strong>：将边&lt;E,G&gt;加入R中。<br>  上一步操作之后，边&lt;E,G&gt;的权值最小，因此将它加入到最小生成树结果R中。<br><strong>第6步</strong>：将边&lt;A,B&gt;加入R中。<br>  上一步操作之后，边&lt;F,G&gt;的权值最小，但&lt;F,G&gt;会和已有的边构成回路；因此，跳过边&lt;F,G&gt;。同理，跳过边&lt;B,C&gt;。将边&lt;A,B&gt;加入到最小生成树结果R中。</p><p>此时，最小生成树构造完成！它包括的边依次是：<strong>&lt;E,F&gt; &lt;C,D&gt; &lt;D,E&gt; &lt;B,F&gt; &lt;E,G&gt; &lt;A,B&gt;</strong>。</p><h2 id="克鲁斯卡尔算法分析"><a href="#克鲁斯卡尔算法分析" class="headerlink" title="克鲁斯卡尔算法分析"></a><strong>克鲁斯卡尔算法分析</strong></h2><p>根据前面介绍的克鲁斯卡尔算法的基本思想和做法，我们能够了解到，克鲁斯卡尔算法重点需要解决的以下两个问题：<br><strong>问题一</strong> 对图的所有边按照权值大小进行排序。<br><strong>问题二</strong> 将边添加到最小生成树中时，怎么样判断是否形成了回路。</p><p>问题一很好解决，采用排序算法进行排序即可。</p><p>问题二处理方式是：<strong>==记录顶点在”最小生成树”中的终点，顶点的终点是”在最小生成树中与它连通的最大顶点”(<em>关于这一点，后面会通过图片给出说明</em>)。然后每次需要将一条边添加到最小生存树时，判断该边的两个顶点的终点是否重合，重合的话则会构成回路。==</strong> 以下图来进行说明：</p><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/kruskal/04.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwn1y7epmpj30aj06c74g.jpg" alt="img"></a></p><p>在将&lt;E,F&gt; &lt;C,D&gt; &lt;D,E&gt;加入到最小生成树R中之后，这几条边的顶点就都有了终点：</p><blockquote><p><strong>(01)</strong> C的终点是F。<br><strong>(02)</strong> D的终点是F。<br><strong>(03)</strong> E的终点是F。<br><strong>(04)</strong> F的终点是F。</p></blockquote><p>关于终点，就是将所有顶点按照从小到大的顺序排列好之后；某个顶点的终点就是”与它连通的最大顶点”。 因此，接下来，虽然&lt;C,E&gt;是权值最小的边。但是C和E的重点都是F，即它们的终点相同，因此，将&lt;C,E&gt;加入最小生成树的话，会形成回路。这就是判断回路的方式。</p><h2 id="克鲁斯卡尔算法的代码说明"><a href="#克鲁斯卡尔算法的代码说明" class="headerlink" title="克鲁斯卡尔算法的代码说明"></a><strong>克鲁斯卡尔算法的代码说明</strong></h2><h3 id="1-基本定义"><a href="#1-基本定义" class="headerlink" title="1. 基本定义"></a><strong>1. 基本定义</strong></h3><p>EData是邻接矩阵边对应的结构体。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 边的结构体</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EData</span> </span>&#123;<br>    <span class="hljs-keyword">char</span> start; <span class="hljs-comment">// 边的起点</span><br>    <span class="hljs-keyword">char</span> end;   <span class="hljs-comment">// 边的终点</span><br>    <span class="hljs-keyword">int</span> weight; <span class="hljs-comment">// 边的权重</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">EData</span><span class="hljs-params">(<span class="hljs-keyword">char</span> start, <span class="hljs-keyword">char</span> end, <span class="hljs-keyword">int</span> weight)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.start = start;<br>        <span class="hljs-keyword">this</span>.end = end;<br>        <span class="hljs-keyword">this</span>.weight = weight;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>MatrixUDG是邻接矩阵对应的结构体。mVexs用于保存顶点，mEdgNum用于保存边数，mMatrix则是用于保存矩阵信息的二维数组。例如，mMatrix[i][j]=1，则表示”顶点i(即mVexs[i])”和”顶点j(即mVexs[j])”是邻接点；mMatrix[i][j]=0，则表示它们不是邻接点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MatrixUDG</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> mEdgNum;        <span class="hljs-comment">// 边的数量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">char</span>[] mVexs;       <span class="hljs-comment">// 顶点集合</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[][] mMatrix;    <span class="hljs-comment">// 邻接矩阵</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> INF = Integer.MAX_VALUE;   <span class="hljs-comment">// 最大值</span><br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-克鲁斯卡尔算法"><a href="#2-克鲁斯卡尔算法" class="headerlink" title="2. 克鲁斯卡尔算法"></a><strong>2. 克鲁斯卡尔算法</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*<br> * 克鲁斯卡尔（Kruskal)最小生成树<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">kruskal</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;                      <span class="hljs-comment">// rets数组的索引</span><br>    <span class="hljs-keyword">int</span>[] vends = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[mEdgNum];     <span class="hljs-comment">// 用于保存"已有最小生成树"中每个顶点在该最小树中的终点。</span><br>    EData[] rets = <span class="hljs-keyword">new</span> EData[mEdgNum];  <span class="hljs-comment">// 结果数组，保存kruskal最小生成树的边</span><br>    EData[] edges;                      <span class="hljs-comment">// 图对应的所有边</span><br><br>    <span class="hljs-comment">// 获取"图中所有的边"</span><br>    edges = getEdges();<br>    <span class="hljs-comment">// 将边按照"权"的大小进行排序(从小到大)</span><br>    sortEdges(edges, mEdgNum);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;mEdgNum; i++) &#123;<br>        <span class="hljs-keyword">int</span> p1 = getPosition(edges[i].start);      <span class="hljs-comment">// 获取第i条边的"起点"的序号</span><br>        <span class="hljs-keyword">int</span> p2 = getPosition(edges[i].end);        <span class="hljs-comment">// 获取第i条边的"终点"的序号</span><br><br>        <span class="hljs-keyword">int</span> m = getEnd(vends, p1);                 <span class="hljs-comment">// 获取p1在"已有的最小生成树"中的终点</span><br>        <span class="hljs-keyword">int</span> n = getEnd(vends, p2);                 <span class="hljs-comment">// 获取p2在"已有的最小生成树"中的终点</span><br>        <span class="hljs-comment">// 如果m!=n，意味着"边i"与"已经添加到最小生成树中的顶点"没有形成环路</span><br>        <span class="hljs-keyword">if</span> (m != n) &#123;<br>            vends[m] = n;                       <span class="hljs-comment">// 设置m在"已有的最小生成树"中的终点为n</span><br>            rets[index++] = edges[i];           <span class="hljs-comment">// 保存结果</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 统计并打印"kruskal最小生成树"的信息</span><br>    <span class="hljs-keyword">int</span> length = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; index; i++)<br>        length += rets[i].weight;<br>    System.out.printf(<span class="hljs-string">"Kruskal=%d: "</span>, length);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; index; i++)<br>        System.out.printf(<span class="hljs-string">"(%c,%c) "</span>, rets[i].start, rets[i].end);<br>    System.out.printf(<span class="hljs-string">"\n"</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="普里姆-Prim-算法"><a href="#普里姆-Prim-算法" class="headerlink" title="普里姆(Prim)算法"></a>普里姆(Prim)算法</h1><p>普里姆(Prim)算法，是用来求加权连通图的最小生成树的算法。</p><p><strong>基本思想</strong><br>对于图G而言，V是所有顶点的集合；现在，设置两个新的集合U和T，其中U用于存放G的最小生成树中的顶点，T存放G的最小生成树中的边。 从所有uЄU，vЄ(V-U) (V-U表示出去U的所有顶点)的边中选取权值最小的边(u, v)，将顶点v加入集合U中，将边(u, v)加入集合T中，如此不断重复，直到U=V为止，最小生成树构造完毕，这时集合T中包含了最小生成树中的所有边。</p><h2 id="普里姆算法图解"><a href="#普里姆算法图解" class="headerlink" title="普里姆算法图解"></a><strong>普里姆算法图解</strong></h2><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/prim/01.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwn3kzc05yj30aj07et8v.jpg" alt="img"></a></p><p>以上图G4为例，来对普里姆进行演示(从第一个顶点A开始通过普里姆算法生成最小生成树)。</p><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/prim/02.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwn3l4fltij30eq184jv3.jpg" alt="img"></a></p><p><strong>初始状态</strong>：V是所有顶点的集合，即V={A,B,C,D,E,F,G}；U和T都是空！<br><strong>第1步</strong>：将顶点A加入到U中。<br>  此时，U={A}。<br><strong>第2步</strong>：将顶点B加入到U中。<br>  上一步操作之后，U={A}, V-U={B,C,D,E,F,G}；因此，边(A,B)的权值最小。将顶点B添加到U中；此时，U={A,B}。<br><strong>第3步</strong>：将顶点F加入到U中。<br>  上一步操作之后，U={A,B}, V-U={C,D,E,F,G}；因此，边(B,F)的权值最小。将顶点F添加到U中；此时，U={A,B,F}。<br><strong>第4步</strong>：将顶点E加入到U中。<br>  上一步操作之后，U={A,B,F}, V-U={C,D,E,G}；因此，边(F,E)的权值最小。将顶点E添加到U中；此时，U={A,B,F,E}。<br><strong>第5步</strong>：将顶点D加入到U中。<br>  上一步操作之后，U={A,B,F,E}, V-U={C,D,G}；因此，边(E,D)的权值最小。将顶点D添加到U中；此时，U={A,B,F,E,D}。<br><strong>第6步</strong>：将顶点C加入到U中。<br>  上一步操作之后，U={A,B,F,E,D}, V-U={C,G}；因此，边(D,C)的权值最小。将顶点C添加到U中；此时，U={A,B,F,E,D,C}。<br><strong>第7步</strong>：将顶点G加入到U中。<br>  上一步操作之后，U={A,B,F,E,D,C}, V-U={G}；因此，边(F,G)的权值最小。将顶点G添加到U中；此时，U=V。</p><p>此时，最小生成树构造完成！它包括的顶点依次是：<strong>A B F E D C G</strong>。</p><h2 id="普里姆算法的代码说明"><a href="#普里姆算法的代码说明" class="headerlink" title="普里姆算法的代码说明"></a><strong>普里姆算法的代码说明</strong></h2><h3 id="1-基本定义-1"><a href="#1-基本定义-1" class="headerlink" title="1. 基本定义"></a><strong>1. 基本定义</strong></h3><p>MatrixUDG是邻接矩阵对应的结构体。mVexs用于保存顶点，mEdgNum用于保存边数，mMatrix则是用于保存矩阵信息的二维数组。例如，mMatrix[i][j]=1，则表示”顶点i(即mVexs[i])”和”顶点j(即mVexs[j])”是邻接点；mMatrix[i][j]=0，则表示它们不是邻接点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MatrixUDG</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">char</span>[] mVexs;       <span class="hljs-comment">// 顶点集合</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[][] mMatrix;    <span class="hljs-comment">// 邻接矩阵</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> INF = Integer.MAX_VALUE;   <span class="hljs-comment">// 最大值</span><br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-普里姆算法"><a href="#2-普里姆算法" class="headerlink" title="2. 普里姆算法"></a><strong>2. 普里姆算法</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*<br> * prim最小生成树<br> *<br> * 参数说明：<br> *   start -- 从图中的第start个元素开始，生成最小树<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">prim</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> num = mVexs.length;         <span class="hljs-comment">// 顶点个数</span><br>    <span class="hljs-keyword">int</span> index=<span class="hljs-number">0</span>;                    <span class="hljs-comment">// prim最小树的索引，即prims数组的索引</span><br>    <span class="hljs-keyword">char</span>[] prims  = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[num];  <span class="hljs-comment">// prim最小树的结果数组</span><br>    <span class="hljs-keyword">int</span>[] weights = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[num];   <span class="hljs-comment">// 顶点间边的权值</span><br><br>    <span class="hljs-comment">// prim最小生成树中第一个数是"图中第start个顶点"，因为是从start开始的。</span><br>    prims[index++] = mVexs[start];<br><br>    <span class="hljs-comment">// 初始化"顶点的权值数组"，</span><br>    <span class="hljs-comment">// 将每个顶点的权值初始化为"第start个顶点"到"该顶点"的权值。</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; num; i++ )<br>        weights[i] = mMatrix[start][i];<br>    <span class="hljs-comment">// 将第start个顶点的权值初始化为0。</span><br>    <span class="hljs-comment">// 可以理解为"第start个顶点到它自身的距离为0"。</span><br>    weights[start] = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; num; i++) &#123;<br>        <span class="hljs-comment">// 由于从start开始的，因此不需要再对第start个顶点进行处理。</span><br>        <span class="hljs-keyword">if</span>(start == i)<br>            <span class="hljs-keyword">continue</span>;<br><br>        <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> min = INF;<br>        <span class="hljs-comment">// 在未被加入到最小生成树的顶点中，找出权值最小的顶点。</span><br>        <span class="hljs-keyword">while</span> (j &lt; num) &#123;<br>            <span class="hljs-comment">// 若weights[j]=0，意味着"第j个节点已经被排序过"(或者说已经加入了最小生成树中)。</span><br>            <span class="hljs-keyword">if</span> (weights[j] != <span class="hljs-number">0</span> &amp;&amp; weights[j] &lt; min) &#123;<br>                min = weights[j];<br>                k = j;<br>            &#125;<br>            j++;<br>        &#125;<br><br>        <span class="hljs-comment">// 经过上面的处理后，在未被加入到最小生成树的顶点中，权值最小的顶点是第k个顶点。</span><br>        <span class="hljs-comment">// 将第k个顶点加入到最小生成树的结果数组中</span><br>        prims[index++] = mVexs[k];<br>        <span class="hljs-comment">// 将"第k个顶点的权值"标记为0，意味着第k个顶点已经排序过了(或者说已经加入了最小树结果中)。</span><br>        weights[k] = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 当第k个顶点被加入到最小生成树的结果数组中之后，更新其它顶点的权值。</span><br>        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span> ; j &lt; num; j++) &#123;<br>            <span class="hljs-comment">// 当第j个节点没有被处理，并且需要更新时才被更新。</span><br>            <span class="hljs-keyword">if</span> (weights[j] != <span class="hljs-number">0</span> &amp;&amp; mMatrix[k][j] &lt; weights[j])<br>                weights[j] = mMatrix[k][j];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 计算最小生成树的权值</span><br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; index; i++) &#123;<br>        <span class="hljs-keyword">int</span> min = INF;<br>        <span class="hljs-comment">// 获取prims[i]在mMatrix中的位置</span><br>        <span class="hljs-keyword">int</span> n = getPosition(prims[i]);<br>        <span class="hljs-comment">// 在vexs[0...i]中，找出到j的权值最小的顶点。</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>            <span class="hljs-keyword">int</span> m = getPosition(prims[j]);<br>            <span class="hljs-keyword">if</span> (mMatrix[m][n]&lt;min)<br>                min = mMatrix[m][n];<br>        &#125;<br>        sum += min;<br>    &#125;<br>    <span class="hljs-comment">// 打印最小生成树</span><br>    System.out.printf(<span class="hljs-string">"PRIM(%c)=%d: "</span>, mVexs[start], sum);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; index; i++)<br>        System.out.printf(<span class="hljs-string">"%c "</span>, prims[i]);<br>    System.out.printf(<span class="hljs-string">"\n"</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;最小生成树-Prime-Kruskal&quot;&gt;&lt;a href=&quot;#最小生成树-Prime-Kruskal&quot; class=&quot;headerlink&quot; title=&quot;最小生成树(Prime, Kruskal)&quot;&gt;&lt;/a&gt;最小生成树(Prime, Kruskal)&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
      <category term="Data Structure" scheme="http://yoursite.com/categories/Data-Structure/"/>
    
    
      <category term="Data Structure" scheme="http://yoursite.com/tags/Data-Structure/"/>
    
  </entry>
  
  <entry>
    <title>7.4.图的拓扑排序</title>
    <link href="http://yoursite.com/2022/01/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/7.4.%E5%9B%BE%E7%9A%84%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2022/01/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/7.4.%E5%9B%BE%E7%9A%84%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</id>
    <published>2022-01-16T14:34:39.000Z</published>
    <updated>2022-02-21T00:54:33.379Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图的应用"><a href="#图的应用" class="headerlink" title="图的应用"></a>图的应用</h1><h2 id="一、拓扑排序"><a href="#一、拓扑排序" class="headerlink" title="一、拓扑排序"></a>一、拓扑排序</h2><h3 id="1-拓扑排序介绍"><a href="#1-拓扑排序介绍" class="headerlink" title="1. 拓扑排序介绍"></a><strong>1. 拓扑排序介绍</strong></h3><p>拓扑排序(Topological Order)是指，将一个<strong>有向无环图</strong>(Directed Acyclic Graph简称DAG)进行排序进而得到一个有序的线性序列。</p><p>拓扑排序通常用来“排序”具有依赖关系的任务。比如，如果用一个DAG图来表示一个工程，其中每个顶点表示工程中的一个任务，用有向边 表示在做任务 B 之前必须先完成任务 A。故在这个工程中，任意两个任务要么具有确定的先后关系，要么是没有关系，绝对不存在互相矛盾的关系（即环路）。</p><p>如果AOV网络有n个顶点，e条边，在拓扑排序的过程中，搜索入度为零的顶点所需的时间是O(n)。在正常情况下，每个顶点进一次栈，出一次栈，所需时间O(n)。每个顶点入度减1的运算共执行了e次。所以总的时间复杂为O(n+e)。</p><h3 id="2-拓扑排序的算法图解"><a href="#2-拓扑排序的算法图解" class="headerlink" title="2. 拓扑排序的算法图解"></a><strong>2. 拓扑排序的算法图解</strong></h3><p>拓扑排序算法的基本步骤：</p><blockquote><p><strong>1.</strong> 构造一个队列Q(queue) 和 拓扑排序的结果队列T(topological)；<br><strong>2.</strong> 把所有没有依赖顶点的节点放入Q；<br><strong>3.</strong> 当Q还有顶点的时候，执行下面步骤：<br><strong>3.1</strong> 从Q中取出一个顶点n(将n从Q中删掉)，并放入T(将n加入到结果集中)；<br><strong>3.2</strong> 对n每一个邻接点m(n是起点，m是终点)；<br><strong>3.2.1</strong> 去掉边&lt;n,m&gt;;<br><strong>3.2.2</strong> 如果m没有依赖顶点，则把m放入Q;<br><em>注：顶点A没有依赖顶点，是指不存在以A为终点的边。</em></p></blockquote><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/topsort/01.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwmtodh85wj308f08ywek.jpg" alt="img"></a></p><p>以上图为例，来对拓扑排序进行演示。</p><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/topsort/02.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwmtonrt51j30aj0tfaax.jpg" alt="img"></a></p><p><strong>第1步</strong>：将B和C加入到排序结果中。<br>  顶点B和顶点C都是没有依赖顶点，因此将C和C加入到结果集T中。假设ABCDEFG按顺序存储，因此先访问B，再访问C。访问B之后，去掉边&lt;B,A&gt;和&lt;B,D&gt;，并将A和D加入到队列Q中。同样的，去掉边&lt;C,F&gt;和&lt;C,G&gt;，并将F和G加入到Q中。<br>  (01) 将B加入到排序结果中，然后去掉边&lt;B,A&gt;和&lt;B,D&gt;；此时，由于A和D没有依赖顶点，因此并将A和D加入到队列Q中。<br>  (02) 将C加入到排序结果中，然后去掉边&lt;C,F&gt;和&lt;C,G&gt;；此时，由于F有依赖顶点D，G有依赖顶点A，因此不对F和G进行处理。<br><strong>第2步</strong>：将A,D依次加入到排序结果中。<br>  第1步访问之后，A,D都是没有依赖顶点的，根据存储顺序，先访问A，然后访问D。访问之后，删除顶点A和顶点D的出边。<br><strong>第3步</strong>：将E,F,G依次加入到排序结果中。</p><p>因此访问顺序是：<strong>B -&gt; C -&gt; A -&gt; D -&gt; E -&gt; F -&gt; G</strong></p><h3 id="3-拓扑排序的代码"><a href="#3-拓扑排序的代码" class="headerlink" title="3. 拓扑排序的代码"></a><strong>3. 拓扑排序的代码</strong></h3><h4 id="1-基本定义"><a href="#1-基本定义" class="headerlink" title="1. 基本定义"></a><strong>1. 基本定义</strong></h4><p>拓扑排序是对有向无环图的排序。下面以邻接表实现的有向图来对拓扑排序进行说明。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListDG</span> </span>&#123;<br>    <span class="hljs-comment">// 邻接表中表对应的链表的顶点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ENode</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ivex;       <span class="hljs-comment">// 该边所指向的顶点的位置</span><br>        ENode nextEdge; <span class="hljs-comment">// 指向下一条弧的指针</span><br>    &#125;<br><br>    <span class="hljs-comment">// 邻接表中表的顶点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VNode</span> </span>&#123;<br>        <span class="hljs-keyword">char</span> data;          <span class="hljs-comment">// 顶点信息</span><br>        ENode firstEdge;    <span class="hljs-comment">// 指向第一条依附该顶点的弧</span><br>    &#125;;<br><br>    <span class="hljs-keyword">private</span> VNode[] mVexs;  <span class="hljs-comment">// 顶点数组</span><br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>(1)</strong> ListDG是邻接表对应的结构体。 mVexs则是保存顶点信息的一维数组。<br><strong>(2)</strong> VNode是邻接表顶点对应的结构体。 data是顶点所包含的数据，而firstEdge是该顶点所包含链表的表头指针。<br><strong>(3)</strong> ENode是邻接表顶点所包含的链表的节点对应的结构体。 ivex是该节点所对应的顶点在vexs中的索引，而nextEdge是指向下一个节点的。</p><h4 id="2-拓扑排序"><a href="#2-拓扑排序" class="headerlink" title="2. 拓扑排序"></a><strong>2. 拓扑排序</strong></h4><p>说明：<br><strong>(1)</strong> queue的作用就是用来存储没有依赖顶点的顶点。它与前面所说的Q相对应。<br><strong>(2)</strong> tops的作用就是用来存储排序结果。它与前面所说的T相对应。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*<br> * 拓扑排序<br> *<br> * 返回值：<br> *     -1 -- 失败(由于内存不足等原因导致)<br> *      0 -- 成功排序，并输入结果<br> *      1 -- 失败(该有向图是有环的)<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">topologicalSort</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> num = mVexs.size();<br>    <span class="hljs-keyword">int</span>[] ins;               <span class="hljs-comment">// 入度数组</span><br>    <span class="hljs-keyword">char</span>[] tops;             <span class="hljs-comment">// 拓扑排序结果数组，记录每个节点的排序后的序号。</span><br>    Queue&lt;Integer&gt; queue;    <span class="hljs-comment">// 辅组队列</span><br><br>    ins   = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[num];<br>    tops  = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[num];<br>    queue = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();<br><br>    <span class="hljs-comment">// 统计每个顶点的入度数</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; num; i++) &#123;<br><br>        ENode node = mVexs.get(i).firstEdge; <span class="hljs-comment">//获取以该顶点为起点的出边队列</span><br>        <span class="hljs-keyword">while</span> (node != <span class="hljs-keyword">null</span>) &#123;<br>            ins[node.ivex]++;<br>            node = node.nextEdge;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 将所有入度为0的顶点入队列</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; num; i ++)<br>        <span class="hljs-keyword">if</span>(ins[i] == <span class="hljs-number">0</span>)<br>            queue.offer(i);                 <span class="hljs-comment">// 入队列</span><br><br>    <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;              <span class="hljs-comment">// 队列非空</span><br>        <span class="hljs-keyword">int</span> j = queue.poll().intValue();    <span class="hljs-comment">// 出队列。j是顶点的序号</span><br>        tops[index++] = mVexs.get(j).data;  <span class="hljs-comment">// 将该顶点添加到tops中，tops是排序结果</span><br>        ENode node = mVexs.get(j).firstEdge;<span class="hljs-comment">// 获取以该顶点为起点的出边队列</span><br><br>        <span class="hljs-comment">// 将与"node"关联的节点的入度减1；</span><br>        <span class="hljs-comment">// 若减1之后，该节点的入度为0；则将该节点添加到队列中。</span><br>        <span class="hljs-keyword">while</span>(node != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 将节点(序号为node.ivex)的入度减1。</span><br>            ins[node.ivex]--;<br>            <span class="hljs-comment">// 若节点的入度为0，则将其"入队列"</span><br>            <span class="hljs-keyword">if</span>( ins[node.ivex] == <span class="hljs-number">0</span>)<br>                queue.offer(node.ivex);    <span class="hljs-comment">// 入队列</span><br><br>            node = node.nextEdge;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(index != num) &#123;<br>        System.out.printf(<span class="hljs-string">"Graph has a cycle\n"</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 打印拓扑排序结果</span><br>    System.out.printf(<span class="hljs-string">"== TopSort: "</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; num; i ++)<br>        System.out.printf(<span class="hljs-string">"%c "</span>, tops[i]);<br>    System.out.printf(<span class="hljs-string">"\n"</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;图的应用&quot;&gt;&lt;a href=&quot;#图的应用&quot; class=&quot;headerlink&quot; title=&quot;图的应用&quot;&gt;&lt;/a&gt;图的应用&lt;/h1&gt;&lt;h2 id=&quot;一、拓扑排序&quot;&gt;&lt;a href=&quot;#一、拓扑排序&quot; class=&quot;headerlink&quot; title=&quot;一、拓扑排
      
    
    </summary>
    
    
      <category term="Data Structure" scheme="http://yoursite.com/categories/Data-Structure/"/>
    
    
      <category term="Data Structure" scheme="http://yoursite.com/tags/Data-Structure/"/>
    
  </entry>
  
  <entry>
    <title>7.3.图的遍历(DFS,BFS)</title>
    <link href="http://yoursite.com/2022/01/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/7.3.%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86(DFS,BFS)/"/>
    <id>http://yoursite.com/2022/01/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/7.3.%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86(DFS,BFS)/</id>
    <published>2022-01-14T14:32:39.000Z</published>
    <updated>2022-02-21T00:54:33.379Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a><strong>图的遍历</strong></h1><h2 id="一、深度优先搜索-Depth-First-Search-DFS"><a href="#一、深度优先搜索-Depth-First-Search-DFS" class="headerlink" title="一、深度优先搜索(Depth First Search, DFS)"></a>一、深度优先搜索(Depth First Search, DFS)</h2><h3 id="1-深度优先搜索介绍"><a href="#1-深度优先搜索介绍" class="headerlink" title="1. 深度优先搜索介绍"></a><strong>1. 深度优先搜索介绍</strong></h3><p>图的深度优先搜索(Depth First Search)，和树的先序遍历比较类似。</p><p>它的思想：假设初始状态是图中所有顶点均未被访问，则从某个顶点v出发，首先访问该顶点，然后依次从它的各个未被访问的邻接点出发深度优先搜索遍历图，直至图中所有和v有路径相通的顶点都被访问到。 若此时尚有其他顶点未被访问到，则另选一个未被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。</p><p>显然，深度优先搜索是一个递归的过程。</p><h3 id="2-深度优先搜索图解"><a href="#2-深度优先搜索图解" class="headerlink" title="2. 深度优先搜索图解"></a><strong>2. 深度优先搜索图解</strong></h3><h4 id="2-1-无向图的深度优先搜索"><a href="#2-1-无向图的深度优先搜索" class="headerlink" title="2.1 无向图的深度优先搜索"></a><strong>2.1 无向图的深度优先搜索</strong></h4><p>下面以”无向图”为例，来对深度优先搜索进行演示。</p><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/iterator/01.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwmlnfvwp5j30bl08f74e.jpg" alt="img"></a></p><p>对上面的图G1进行深度优先遍历，从顶点A开始。</p><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/iterator/02.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwmlngl8zqj30c409h0t0.jpg" alt="img"></a></p><p><strong>第1步</strong>：访问A。<br><strong>第2步</strong>：访问(A的邻接点)C。<br>  在第1步访问A之后，接下来应该访问的是A的邻接点，即”C,D,F”中的一个。但在本文的实现中，顶点ABCDEFG是按照顺序存储，C在”D和F”的前面，因此，先访问C。<br><strong>第3步</strong>：访问(C的邻接点)B。<br>  在第2步访问C之后，接下来应该访问C的邻接点，即”B和D”中一个(A已经被访问过，就不算在内)。而由于B在D之前，先访问B。<br><strong>第4步</strong>：访问(C的邻接点)D。<br>  在第3步访问了C的邻接点B之后，B没有未被访问的邻接点；因此，返回到访问C的另一个邻接点D。<br><strong>第5步</strong>：访问(A的邻接点)F。<br>  前面已经访问了A，并且访问完了”A的邻接点B的所有邻接点(包括递归的邻接点在内)”；因此，此时返回到访问A的另一个邻接点F。<br><strong>第6步</strong>：访问(F的邻接点)G。<br><strong>第7步</strong>：访问(G的邻接点)E。</p><p>因此访问顺序是：<strong>A -&gt; C -&gt; B -&gt; D -&gt; F -&gt; G -&gt; E</strong></p><h4 id="2-2-有向图的深度优先搜索"><a href="#2-2-有向图的深度优先搜索" class="headerlink" title="2.2 有向图的深度优先搜索"></a><strong>2.2 有向图的深度优先搜索</strong></h4><p>下面以”有向图”为例，来对深度优先搜索进行演示。</p><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/iterator/03.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwmlpwnltaj308f08yt8t.jpg" alt="img"></a></p><p>对上面的图G2进行深度优先遍历，从顶点A开始。</p><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/iterator/04.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwmlpy4gxuj308f0a0wer.jpg" alt="img"></a></p><p><strong>第1步</strong>：访问A。<br><strong>第2步</strong>：访问B。<br>  在访问了A之后，接下来应该访问的是A的出边的另一个顶点，即顶点B。<br><strong>第3步</strong>：访问C。<br>  在访问了B之后，接下来应该访问的是B的出边的另一个顶点，即顶点C,E,F。在本文实现的图中，顶点ABCDEFG按照顺序存储，因此先访问C。<br><strong>第4步</strong>：访问E。<br>  接下来访问C的出边的另一个顶点，即顶点E。<br><strong>第5步</strong>：访问D。<br>  接下来访问E的出边的另一个顶点，即顶点B,D。顶点B已经被访问过，因此访问顶点D。<br><strong>第6步</strong>：访问F。<br>  接下应该回溯”访问A的出边的另一个顶点F”。<br><strong>第7步</strong>：访问G。</p><p>因此访问顺序是：<strong>A -&gt; B -&gt; C -&gt; E -&gt; D -&gt; F -&gt; G</strong></p><h4 id="2-3-代码实现"><a href="#2-3-代码实现" class="headerlink" title="2.3 代码实现"></a>2.3 代码实现</h4><p><strong>邻接矩阵的深度优先遍历</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//邻接矩阵的深度优先遍历</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 深度优先遍历</span><br><span class="hljs-keyword">boolean</span>[] beTraversed = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[<span class="hljs-keyword">this</span>.vertices];<br><span class="hljs-comment">// 保存顶点的遍历状态，默认为false</span><br>beTraversed[<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;<br>System.out.print(<span class="hljs-string">"深度优先遍历结果："</span>);<br>System.out.print(<span class="hljs-keyword">this</span>.vertexList.get(<span class="hljs-number">0</span>));<br><span class="hljs-keyword">this</span>.dfs(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, beTraversed);<br>System.out.println();<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">boolean</span>[] beTraversed)</span> </span>&#123;<br><span class="hljs-comment">// 遍历x的第y个邻接点</span><br><span class="hljs-keyword">while</span> (y &lt; <span class="hljs-keyword">this</span>.vertices) &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.edgeMatrix[x][y] != <span class="hljs-number">0</span> &amp;&amp; !beTraversed[y]) &#123;<br>beTraversed[y] = <span class="hljs-keyword">true</span>;<br>System.out.print(<span class="hljs-keyword">this</span>.vertexList.get(y));<br><span class="hljs-keyword">this</span>.dfs(y, <span class="hljs-number">0</span>, beTraversed); <span class="hljs-comment">// 从y的第0个邻接点开始深度优先遍历</span><br>&#125;<br>y++;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>邻接表的深度优先遍历</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//邻接表的深度优先遍历</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 深度优先遍历</span><br><span class="hljs-keyword">boolean</span>[] beTraversed = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[<span class="hljs-keyword">this</span>.vertices];<br><span class="hljs-comment">// 保存顶点的遍历状态，默认为false</span><br>beTraversed[<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;<br>System.out.print(<span class="hljs-string">"深度优先遍历结果："</span>);<br>System.out.print(<span class="hljs-keyword">this</span>.vertexList[<span class="hljs-number">0</span>].data);<br><span class="hljs-keyword">this</span>.dfs(<span class="hljs-number">0</span>, beTraversed);<br>System.out.println();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">boolean</span>[] beTraversed)</span> </span>&#123;<br><span class="hljs-comment">// 从第i个顶点开始深度优先遍历</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j : <span class="hljs-keyword">this</span>.vertexList[i].adj) &#123;<br><span class="hljs-keyword">if</span> (!beTraversed[j]) &#123;<br>beTraversed[j] = <span class="hljs-keyword">true</span>;<br>System.out.print(<span class="hljs-keyword">this</span>.vertexList[j].data);<br><span class="hljs-keyword">this</span>.dfs(j, beTraversed);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>自己构造邻接表的深度优先遍历</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bean.algorithm.graph;<br> <br><span class="hljs-keyword">import</span> java.util.Iterator;<br><span class="hljs-keyword">import</span> java.util.LinkedList;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DFSGraph</span> </span>&#123;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> V; <span class="hljs-comment">// 定义结点（vertices）</span><br> <br><span class="hljs-comment">// 图的邻接表表示（ Adjacency List）</span><br><span class="hljs-keyword">private</span> LinkedList&lt;Integer&gt; adj[];<br> <br><span class="hljs-comment">// 构造图的构造方法</span><br>DFSGraph(<span class="hljs-keyword">int</span> v) &#123;<br>V = v;<br>adj = <span class="hljs-keyword">new</span> LinkedList[v];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; v; ++i)<br>adj[i] = <span class="hljs-keyword">new</span> LinkedList();<br>&#125;<br> <br><span class="hljs-comment">// 向图中添加边</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span> w)</span> </span>&#123;<br>adj[v].add(w); <br>&#125;<br> <br><span class="hljs-comment">// DFS算法工具</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DFSUtil</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v, <span class="hljs-keyword">boolean</span> visited[])</span> </span>&#123;<br><span class="hljs-comment">// 标记当前结点为已访问（visited）并输出</span><br>visited[v] = <span class="hljs-keyword">true</span>;<br>System.out.print(v + <span class="hljs-string">" "</span>);<br> <br><span class="hljs-comment">// 访问当前的结点的所有邻接结点</span><br>Iterator&lt;Integer&gt; i = adj[v].listIterator();<br><span class="hljs-keyword">while</span> (i.hasNext()) &#123;<br><span class="hljs-keyword">int</span> n = i.next();<br><span class="hljs-keyword">if</span> (!visited[n])<br>DFSUtil(n, visited);<br>&#125;<br>&#125;<br> <br><span class="hljs-comment">// DFS traversal. 用来回溯调用 DFSUtil()工具</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span> </span>&#123;<br><span class="hljs-comment">// 标记所有节点为未访问状态（ not visited），设置初始值为false。</span><br><span class="hljs-keyword">boolean</span> visited[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[V];<br> <br><span class="hljs-comment">// 回溯 DFS traversal</span><br>DFSUtil(v, visited);<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> </span>&#123;<br>DFSGraph g = <span class="hljs-keyword">new</span> DFSGraph(<span class="hljs-number">4</span>);<br> <br>g.addEdge(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>g.addEdge(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>);<br>g.addEdge(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>g.addEdge(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>);<br>g.addEdge(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>g.addEdge(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>);<br> <br>System.out.println(<span class="hljs-string">"下面是DFS搜索结果 "</span> + <span class="hljs-string">"(从2号结点开始)"</span>);<br> <br>g.DFS(<span class="hljs-number">2</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二、广度优先搜索-Breadth-First-Search-BFS"><a href="#二、广度优先搜索-Breadth-First-Search-BFS" class="headerlink" title="二、广度优先搜索(Breadth First Search, BFS)"></a><strong>二、广度优先搜索(Breadth First Search, BFS)</strong></h2><h3 id="1-广度优先搜索介绍"><a href="#1-广度优先搜索介绍" class="headerlink" title="1. 广度优先搜索介绍"></a><strong>1. 广度优先搜索介绍</strong></h3><p>广度优先搜索算法(Breadth First Search)，又称为”宽度优先搜索”或”横向优先搜索”，简称BFS。</p><p>它的思想是：从图中某顶点v出发，在访问了v之后依次访问v的各个未曾访问过的邻接点，然后分别从这些邻接点出发依次访问它们的邻接点，并使得“先被访问的顶点的邻接点先于后被访问的顶点的邻接点被访问，直至图中所有已被访问的顶点的邻接点都被访问到。如果此时图中尚有顶点未被访问，则需要另选一个未曾被访问过的顶点作为新的起始点，重复上述过程，直至图中所有顶点都被访问到为止。</p><p>换句话说，广度优先搜索遍历图的过程是以v为起点，由近至远，依次访问和v有路径相通且路径长度为1,2…的顶点。</p><h3 id="2-广度优先搜索图解"><a href="#2-广度优先搜索图解" class="headerlink" title="2. 广度优先搜索图解"></a><strong>2. 广度优先搜索图解</strong></h3><h4 id="2-1-无向图的广度优先搜索"><a href="#2-1-无向图的广度优先搜索" class="headerlink" title="2.1 无向图的广度优先搜索"></a><strong>2.1 无向图的广度优先搜索</strong></h4><p>下面以”无向图”为例，来对广度优先搜索进行演示。还是以上面的图G1为例进行说明。</p><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/iterator/05.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwmltsvygcj30eq0e7dge.jpg" alt="img"></a></p><p><strong>第1步</strong>：访问A。<br><strong>第2步</strong>：依次访问C,D,F。<br>  在访问了A之后，接下来访问A的邻接点。前面已经说过，在本文实现中，顶点ABCDEFG按照顺序存储的，C在”D和F”的前面，因此，先访问C。再访问完C之后，再依次访问D,F。<br><strong>第3步</strong>：依次访问B,G。<br>  在第2步访问完C,D,F之后，再依次访问它们的邻接点。首先访问C的邻接点B，再访问F的邻接点G。<br><strong>第4步</strong>：访问E。<br>  在第3步访问完B,G之后，再依次访问它们的邻接点。只有G有邻接点E，因此访问G的邻接点E。</p><p>因此访问顺序是：<strong>A -&gt; C -&gt; D -&gt; F -&gt; B -&gt; G -&gt; E</strong></p><h4 id="2-2-有向图的广度优先搜索"><a href="#2-2-有向图的广度优先搜索" class="headerlink" title="2.2 有向图的广度优先搜索"></a><strong>2.2 有向图的广度优先搜索</strong></h4><p>下面以”有向图”为例，来对广度优先搜索进行演示。还是以上面的图G2为例进行说明。</p><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/iterator/06.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwmluvpt0jj30fs0cnq3k.jpg" alt="img"></a></p><p><strong>第1步</strong>：访问A。<br><strong>第2步</strong>：访问B。<br><strong>第3步</strong>：依次访问C,E,F。<br>  在访问了B之后，接下来访问B的出边的另一个顶点，即C,E,F。前面已经说过，在本文实现中，顶点ABCDEFG按照顺序存储的，因此会先访问C，再依次访问E,F。<br><strong>第4步</strong>：依次访问D,G。<br>  在访问完C,E,F之后，再依次访问它们的出边的另一个顶点。还是按照C,E,F的顺序访问，C的已经全部访问过了，那么就只剩下E,F；先访问E的邻接点D，再访问F的邻接点G。</p><p>因此访问顺序是：<strong>A -&gt; B -&gt; C -&gt; E -&gt; F -&gt; D -&gt; G</strong></p><h4 id="2-3-代码实现-1"><a href="#2-3-代码实现-1" class="headerlink" title="2.3 代码实现"></a>2.3 代码实现</h4><p><strong>邻接矩阵的广度优先遍历</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//邻接矩阵的广度优先遍历</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 宽度优先遍历</span><br><span class="hljs-keyword">boolean</span>[] beTraversed = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[<span class="hljs-keyword">this</span>.vertices];<br><span class="hljs-comment">// 保存顶点的遍历状态，默认为false</span><br>beTraversed[<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;<br>Queue queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>beTraversed[<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;<br>queue.offer(<span class="hljs-number">0</span>);<br><br>System.out.print(<span class="hljs-string">"宽度优先遍历："</span>);<br><span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br><span class="hljs-keyword">int</span> index = queue.poll();<br>System.out.print(<span class="hljs-keyword">this</span>.vertexList.get(index));<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.vertices; i++) &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.edgeMatrix[index][i] != <span class="hljs-number">0</span> &amp;&amp; !beTraversed[i]) &#123;<br><span class="hljs-comment">// 找出所有没有访问过的邻接点</span><br>beTraversed[i] = <span class="hljs-keyword">true</span>;<br>queue.offer(i);<br>&#125;<br>&#125;<br>&#125;<br>System.out.println();<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>邻接表的广度优先遍历</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//邻接表的广度优先遍历</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 宽度优先遍历</span><br><span class="hljs-keyword">boolean</span>[] beTraversed = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[<span class="hljs-keyword">this</span>.vertices];<br><span class="hljs-comment">// 保存顶点的遍历状态，默认为false</span><br>beTraversed[<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;<br>Queue queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>beTraversed[<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;<br>queue.offer(<span class="hljs-number">0</span>);<br><br>System.out.print(<span class="hljs-string">"宽度优先遍历："</span>);<br><span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br><span class="hljs-keyword">int</span> index = queue.poll();<br>System.out.print(<span class="hljs-keyword">this</span>.vertexList[index].data);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i : <span class="hljs-keyword">this</span>.vertexList[index].adj) &#123;<br><span class="hljs-comment">// 所有未被访问过的邻接点入队</span><br><span class="hljs-keyword">if</span> (!beTraversed[i]) &#123;<br>beTraversed[i] = <span class="hljs-keyword">true</span>;<br>queue.offer(i);<br>&#125;<br>&#125;<br>&#125;<br>System.out.println();<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;图的遍历&quot;&gt;&lt;a href=&quot;#图的遍历&quot; class=&quot;headerlink&quot; title=&quot;图的遍历&quot;&gt;&lt;/a&gt;&lt;strong&gt;图的遍历&lt;/strong&gt;&lt;/h1&gt;&lt;h2 id=&quot;一、深度优先搜索-Depth-First-Search-DFS&quot;&gt;&lt;a href
      
    
    </summary>
    
    
      <category term="Data Structure" scheme="http://yoursite.com/categories/Data-Structure/"/>
    
    
      <category term="Data Structure" scheme="http://yoursite.com/tags/Data-Structure/"/>
    
  </entry>
  
  <entry>
    <title>7.2.图的概念和储存结构</title>
    <link href="http://yoursite.com/2022/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/7.2.%E5%9B%BE%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%82%A8%E5%AD%98%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2022/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/7.2.%E5%9B%BE%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%82%A8%E5%AD%98%E7%BB%93%E6%9E%84/</id>
    <published>2022-01-13T14:31:39.000Z</published>
    <updated>2022-02-21T01:12:43.397Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图-graph"><a href="#图-graph" class="headerlink" title="图(graph)"></a>图(graph)</h1><h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><h3 id="1-图的定义"><a href="#1-图的定义" class="headerlink" title="1. 图的定义"></a><strong>1. 图的定义</strong></h3><p>定义：图(graph)是由一些点(vertex)和这些点之间的连线(edge)所组成的；其中，点通常被成为”顶点(vertex)”，而点与点之间的连线则被成为”边或弧”(edege)。通常记为，G=(V,E)。</p><h3 id="2-图的种类"><a href="#2-图的种类" class="headerlink" title="2. 图的种类"></a><strong>2. 图的种类</strong></h3><p>根据边是否有方向，将图可以划分为：<strong>无向图</strong>和<strong>有向图</strong></p><h4 id="2-1-无向图"><a href="#2-1-无向图" class="headerlink" title="2.1 无向图"></a><strong>2.1 无向图</strong></h4><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/basic/01.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwmg3skx7zj308f08fjrg.jpg" alt="img"></a></p><p>上面的图G0是无向图，无向图的所有的边都是不区分方向的。G0=(V1,{E1})。其中，</p><p><strong>(1)</strong> V1={A,B,C,D,E,F}。 V1表示由”A,B,C,D,E,F”几个顶点组成的集合。<br><strong>(2)</strong> E1={(A,B),(A,C),(B,C),(B,E),(B,F),(C,F), (C,D),(E,F),(C,E)}。 E1是由边(A,B),边(A,C)…等等组成的集合。其中，(A,C)表示由顶点A和顶点C连接成的边。</p><p><strong>无向完全图</strong>：在一个无向图中，如果任意两顶点都有一条直接边相连接，则称该图为无向完全图。可以证明，在一个含有n个顶点的无向完全图中，有n（n-1）/2条边。</p><h4 id="2-2-有向图"><a href="#2-2-有向图" class="headerlink" title="2.2 有向图"></a><strong>2.2 有向图</strong></h4><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/basic/02.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwmg8f6ii6j308f08yt8t.jpg" alt="img"></a></p><p>上面的图G2是有向图。和无向图不同，有向图的所有的边都是有方向的！ G2=(V2,{A2})。其中，</p><p><strong>(1)</strong> V2={A,C,B,F,D,E,G}。 V2表示由”A,B,C,D,E,F,G”几个顶点组成的集合。<br><strong>(2)</strong> A2={&lt;A,B&gt;,&lt;B,C&gt;,&lt;B,F&gt;,&lt;B,E&gt;,&lt;C,E&gt;,&lt;E,D&gt;,&lt;D,C&gt;,&lt;E,B&gt;,&lt;F,G&gt;}。 E1是由矢量&lt;A,B&gt;,矢量&lt;B,C&gt;…等等组成的集合。其中，矢量&lt;A,B&gt;表示由”顶点A”指向”顶点C”的有向边。</p><p><strong>有向完全图</strong>：在有一个有向图中，如果任意两顶点之间都有方向互为相反的两条弧相连接，则称该图为有向完全图。在一个含有n个顶点的有向完全图中，有n(n-1)条边。</p><h3 id="3-邻接点和度"><a href="#3-邻接点和度" class="headerlink" title="3. 邻接点和度"></a><strong>3. 邻接点和度</strong></h3><h4 id="3-1-邻接点"><a href="#3-1-邻接点" class="headerlink" title="3.1 邻接点"></a><strong>3.1 邻接点</strong></h4><p>一条边上的两个顶点叫做邻接点。<br><em>例如，上面无向图G0中的顶点A和顶点C就是邻接点。</em></p><p>在有向图中，除了邻接点之外；还有”入边”和”出边”的概念。<br>顶点的入边，是指以该顶点为终点的边。而顶点的出边，则是指以该顶点为起点的边。<br><em>例如，上面有向图G2中的B和E是邻接点；&lt;B,E&gt;是B的出边，还是E的入边。</em></p><h4 id="3-2-度"><a href="#3-2-度" class="headerlink" title="3.2 度"></a><strong>3.2 度</strong></h4><p>在无向图中，某个顶点的度是邻接到该顶点的边(或弧)的数目。<br><em>例如，上面无向图G0中顶点A的度是2。</em></p><p>在有向图中，度还有”入度”和”出度”之分。<br>某个顶点的入度，是指以该顶点为终点的边的数目。而顶点的出度，则是指以该顶点为起点的边的数目。<br><strong>顶点的度=入度+出度。</strong><br><em>例如，上面有向图G2中，顶点B的入度是2，出度是3；顶点B的度=2+3=5。</em></p><h3 id="4-路径和回路"><a href="#4-路径和回路" class="headerlink" title="4. 路径和回路"></a><strong>4. 路径和回路</strong></h3><p><strong>路径</strong>：如果顶点(Vm)到顶点(Vn)之间存在一个顶点序列。则表示Vm到Vn是一条路径。<br><strong>路径长度</strong>：路径中”边的数量”。<br><strong>简单路径</strong>：若一条路径上顶点不重复出现，则是简单路径。<br><strong>回路</strong>：若路径的第一个顶点和最后一个顶点相同，则是回路。<br><strong>简单回路</strong>：第一个顶点和最后一个顶点相同，其它各顶点都不重复的回路则是简单回路。</p><h3 id="5-连通图和连通分量"><a href="#5-连通图和连通分量" class="headerlink" title="5. 连通图和连通分量"></a><strong>5. 连通图和连通分量</strong></h3><p><strong>连通图</strong>：对无向图而言，<strong>任意两个顶点之间都存在一条无向路径</strong>，则称该无向图为连通图。 对有向图而言，若图中<strong>任意两个顶点之间都存在一条有向路径</strong>，则称该有向图为强连通图。</p><p><strong>连通分量</strong>：<strong>非连通图中的各个连通子图称为该图的连通分量</strong>。</p><h3 id="6-权"><a href="#6-权" class="headerlink" title="6. 权"></a><strong>6. 权</strong></h3><p>在学习”哈夫曼树”的时候，了解过”权”的概念。图中权的概念与此类似。</p><p>边的权、网：与边有关的数据信息称为权(Weight)。在实际应用中，权值可以有某种含义。例如，在一个反映城市交通线路的图中，边上的权值可以表示该条线路的长度或等级；对于一个电子线路图，边上的权值可以表示两个端点之间的电阻、电流或电压值；对于反映工程进度的图而言，边上的权值可以表示从前一个工程到后一个工程所需要的时间或其他代价等。边上带权的图称为网或网络（network）。</p><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/basic/03.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwmgsy4rtpj308f08faa6.jpg" alt="img"></a></p><p>上面就是一个带权的图。</p><h3 id="7-生成树"><a href="#7-生成树" class="headerlink" title="7. 生成树"></a>7. 生成树</h3><p>所谓连通图G的生成树，是G的包含其全部n个顶点的一个极小连通子图，所谓极小连通子图是指在包含所有顶点且保证连通的前提下尽可能少地包含原图中的边。生成树必定包含且仅包含连通图G的n-1条边。在生成树中添加任意一条属于原图中的边必定会产生回路，因为新添加的边使其所依附的两个顶点之间有了第二条路径。若生成树中减少任意一条边，则必然成为非连通的。</p><h3 id="8-生成森林"><a href="#8-生成森林" class="headerlink" title="8. 生成森林"></a>8. 生成森林</h3><p>在非连通图中，由每个连通分量都可得到一个极小连通子图，即一棵生成树。这些连通分量的生成树就组成了一个非连通图的生成森林。</p><h2 id="二、图的存储结构"><a href="#二、图的存储结构" class="headerlink" title="二、图的存储结构"></a>二、图的存储结构</h2><h3 id="1-邻接矩阵"><a href="#1-邻接矩阵" class="headerlink" title="1. 邻接矩阵"></a><strong>1. 邻接矩阵</strong></h3><p>邻接矩阵是指用矩阵来表示图。它是采用矩阵来描述图中顶点之间的关系(及弧或边的权)。<br>假设图中顶点数为n，则邻接矩阵定义为：</p><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/basic/04.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwmh21hzetj30bl035gln.jpg" alt="img"></a><br>下面通过示意图来进行解释。</p><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/basic/05.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwmh227kinj30lk08ymxu.jpg" alt="img"></a></p><p>图中的G1是无向图和它对应的邻接矩阵。</p><p>无向图的邻接矩阵是一个对称矩阵，是因为边不具有方向性，所以在邻接矩阵中对角线上皆为0。</p><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/basic/06.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwmh2xdkz2j30l108ygmb.jpg" alt="img"></a></p><p>图中的G2是无向图和它对应的邻接矩阵。</p><p>有向图由于边具有方向性，因此彼此顶点之间并不能相互达到，所以其邻接矩阵的对称性不再。</p><p>通常采用两个数组来实现邻接矩阵：一个一维数组用来保存顶点信息，一个二维数组来用保存边的信息。而根据实际情况可以分析得，图中的顶点并不是任意两个顶点间都会相连，不是都需要对其边上权重进行存储。那么存储的邻接矩阵实际上会存在大量的0。虽然可以通过稀疏表示等方式对稀疏性高的矩阵进行关键信息的存储，但是却增加了图存储的复杂性。<br><strong>缺点</strong>:就是比较耗费空间。</p><h3 id="2-邻接表"><a href="#2-邻接表" class="headerlink" title="2. 邻接表"></a><strong>2. 邻接表</strong></h3><p>邻接表是图的一种链式存储表示方法。它是改进后的”邻接矩阵”。</p><p><strong>缺点：是不方便判断两个顶点之间是否有边。</strong></p><p><strong>优点：相对邻接矩阵来说更省空间。</strong></p><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/basic/07.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwmh65wupuj30n409hmxw.jpg" alt="img"></a></p><p>图中的G1是无向图和它对应的邻接矩阵。</p><p><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/basic/08.jpg?raw=true" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwmh97vnlnj30lk09hdgh.jpg" alt="img"></a></p><p>图中的G2是无向图和它对应的邻接矩阵。</p><p>由此看出，<strong>在对有向图进行表示时，邻接表只能求出图的出度，而无法求出入度。</strong>这个问题很好解决，那就是增加一个表用来存储能够到达某个顶点的相邻顶点。这个表称作逆邻接表。</p><h3 id="3-逆邻接表"><a href="#3-逆邻接表" class="headerlink" title="3. 逆邻接表"></a>3. <strong>逆邻接表</strong></h3><p>逆邻接表与邻接表结构类似，只不过图的顶点链接着能够到达该顶点的相邻顶点。也就是说，邻接表时顺着图中的箭头寻找相邻顶点，而逆邻接表时逆着图中的箭头寻找相邻顶点。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwmhhjp483j314o0jedha.jpg" alt="image-20211121085043748"></p><p>邻接表和逆邻接表的共同使用下，就能够把一个完整的有向图结构进行表示。可以发现，邻接表和逆邻接表实际上有一部分数据时重合的，因此可以将两个表合二为一，从而得到了所谓的十字链表。</p><h3 id="4-十字链表"><a href="#4-十字链表" class="headerlink" title="4. 十字链表"></a>4. <strong>十字链表</strong></h3><p>十字链表似乎很简单，只需要通过相同的顶点分别链向以该顶点为终点和起点的相邻顶点即可。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwmhjkii88j314e0icgns.jpg" alt="image-20211121085241805"></p><p>但这并不是最优的表示方式。虽然这样的方式共用了中间的顶点存储空间，但是邻接表和逆邻接表的链表节点中重复出现的顶点并没有得到重复利用，反而是进行了再次存储。因此，上图的表示方式还可以进行进一步优化。</p><p>十字链表优化后，可通过扩展的顶点结构和边结构来进行正逆邻接表的存储：（下面的弧头可看作是边的箭头那端，弧尾可看作是边的圆点那端）</p><p><strong>顶点结构</strong></p><blockquote><p><strong>data</strong>：用于存储该顶点中的数据； </p><p><strong>firstin指针</strong>：用于连接以当前顶点为弧头的其他顶点构成的链表，即从别的顶点指进来的顶点；</p><p><strong>firstout指针</strong>：用于连接以当前顶点为弧尾的其他顶点构成的链表，即从该顶点指出去的顶点;</p></blockquote><p><strong>边结构</strong>通过存储两个顶点来确定一条边，同时通过分别代表这两个顶点的指针来与相邻顶点进行链接：</p><blockquote><p><strong>tailvex</strong>：用于存储作为弧尾的顶点的编号； </p><p><strong>headvex</strong>：用于存储作为弧头的顶点的编号； </p><p><strong>headlink 指针</strong>：用于链接下一个存储作为弧头的顶点的节点； </p><p><strong>taillink 指针</strong>：用于链接下一个存储作为弧尾的顶点的节点；</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwmhunyr03j31q90u0q7p.jpg" alt="image-20211121090318141"></p><p>以上图为例子，对于顶点A而言，其作为起点能够到达顶点E。因此在邻接表中顶点A要通过边<code>AE</code>（即边04）指向顶点E，顶点A的<code>firstout</code>指针需要指向边04的<code>tailvex</code>。同时，从B出发能够到达A，所以在逆邻接表中顶点A要通过边<code>AB</code>（即边10）指向B，顶点A的<code>firstin</code>指针需要指向边10的弧头，即<code>headlink</code>指针。依次类推。</p><p>十字链表采用了一种看起来比较繁乱的方式对边的方向性进行了表示，能够在尽可能降低存储空间的情况下增加指针保留顶点之间的方向性。具体的操作可能一时间不好弄懂，建议多看几次上图，弄清指针指向的意义，明白正向和逆向邻接表的表示。</p><h2 id="三、代码实现"><a href="#三、代码实现" class="headerlink" title="三、代码实现"></a>三、代码实现</h2><h3 id="1-邻接矩阵无向图"><a href="#1-邻接矩阵无向图" class="headerlink" title="1. 邻接矩阵无向图"></a>1. 邻接矩阵无向图</h3><p><strong>基本定义</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MatrixUDG</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">char</span>[] mVexs;       <span class="hljs-comment">// 顶点集合</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[][] mMatrix;    <span class="hljs-comment">// 邻接矩阵</span><br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>这里介绍提供了两个创建矩阵的方法。一个是<strong>用已知数据</strong>，另一个则<strong>需要用户手动输入数据</strong>。</p><h4 id="1-1-创建图-用已提供的矩阵"><a href="#1-1-创建图-用已提供的矩阵" class="headerlink" title="1.1 创建图(用已提供的矩阵)"></a><strong>1.1 创建图(用已提供的矩阵)</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*<br> * 创建图(用已提供的矩阵)<br> *<br> * 参数说明：<br> *     vexs  -- 顶点数组<br> *     edges -- 边数组<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MatrixUDG</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] vexs, <span class="hljs-keyword">char</span>[][] edges)</span> </span>&#123;<br><br>    <span class="hljs-comment">// 初始化"顶点数"和"边数"</span><br>    <span class="hljs-keyword">int</span> vlen = vexs.length;<br>    <span class="hljs-keyword">int</span> elen = edges.length;<br><br>    <span class="hljs-comment">// 初始化"顶点"</span><br>    mVexs = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[vlen];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mVexs.length; i++)<br>        mVexs[i] = vexs[i];<br><br>    <span class="hljs-comment">// 初始化"边"</span><br>    mMatrix = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[vlen][vlen];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; elen; i++) &#123;<br>        <span class="hljs-comment">// 读取边的起始顶点和结束顶点</span><br>        <span class="hljs-keyword">int</span> p1 = getPosition(edges[i][<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">int</span> p2 = getPosition(edges[i][<span class="hljs-number">1</span>]);<br><br>        mMatrix[p1][p2] = <span class="hljs-number">1</span>;<br>        mMatrix[p2][p1] = <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数的作用是利用已知数据来创建一个邻接矩阵无向图。 实际上，在本文的测试程序源码中，该方法创建的无向图就是上面图G1。具体的调用代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">char</span>[] vexs = &#123;<span class="hljs-string">'A'</span>, <span class="hljs-string">'B'</span>, <span class="hljs-string">'C'</span>, <span class="hljs-string">'D'</span>, <span class="hljs-string">'E'</span>, <span class="hljs-string">'F'</span>, <span class="hljs-string">'G'</span>&#125;;<br>    <span class="hljs-keyword">char</span>[][] edges = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[][]&#123;<br>        &#123;<span class="hljs-string">'A'</span>, <span class="hljs-string">'C'</span>&#125;, <br>        &#123;<span class="hljs-string">'A'</span>, <span class="hljs-string">'D'</span>&#125;, <br>        &#123;<span class="hljs-string">'A'</span>, <span class="hljs-string">'F'</span>&#125;, <br>        &#123;<span class="hljs-string">'B'</span>, <span class="hljs-string">'C'</span>&#125;, <br>        &#123;<span class="hljs-string">'C'</span>, <span class="hljs-string">'D'</span>&#125;, <br>        &#123;<span class="hljs-string">'E'</span>, <span class="hljs-string">'G'</span>&#125;, <br>        &#123;<span class="hljs-string">'F'</span>, <span class="hljs-string">'G'</span>&#125;&#125;;<br>    MatrixUDG pG;<br><br>    pG = <span class="hljs-keyword">new</span> MatrixUDG(vexs, edges);<br></code></pre></td></tr></table></figure><h4 id="1-2-创建图-自己输入"><a href="#1-2-创建图-自己输入" class="headerlink" title="1.2 创建图(自己输入)"></a><strong>1.2 创建图(自己输入)</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* <br> * 创建图(自己输入数据)<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MatrixUDG</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-comment">// 输入"顶点数"和"边数"</span><br>    System.out.printf(<span class="hljs-string">"input vertex number: "</span>);<br>    <span class="hljs-keyword">int</span> vlen = readInt();<br>    System.out.printf(<span class="hljs-string">"input edge number: "</span>);<br>    <span class="hljs-keyword">int</span> elen = readInt();<br>    <span class="hljs-keyword">if</span> ( vlen &lt; <span class="hljs-number">1</span> || elen &lt; <span class="hljs-number">1</span> || (elen &gt; (vlen*(vlen - <span class="hljs-number">1</span>)))) &#123;<br>        System.out.printf(<span class="hljs-string">"input error: invalid parameters!\n"</span>);<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化"顶点"</span><br>    mVexs = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[vlen];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mVexs.length; i++) &#123;<br>        System.out.printf(<span class="hljs-string">"vertex(%d): "</span>, i);<br>        mVexs[i] = readChar();<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化"边"</span><br>    mMatrix = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[vlen][vlen];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; elen; i++) &#123;<br>        <span class="hljs-comment">// 读取边的起始顶点和结束顶点</span><br>        System.out.printf(<span class="hljs-string">"edge(%d):"</span>, i);<br>        <span class="hljs-keyword">char</span> c1 = readChar();<br>        <span class="hljs-keyword">char</span> c2 = readChar();<br>        <span class="hljs-keyword">int</span> p1 = getPosition(c1);<br>        <span class="hljs-keyword">int</span> p2 = getPosition(c2);<br><br>        <span class="hljs-keyword">if</span> (p1==-<span class="hljs-number">1</span> || p2==-<span class="hljs-number">1</span>) &#123;<br>            System.out.printf(<span class="hljs-string">"input error: invalid edge!\n"</span>);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br><br>        mMatrix[p1][p2] = <span class="hljs-number">1</span>;<br>        mMatrix[p2][p1] = <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-邻接矩阵有向图"><a href="#2-邻接矩阵有向图" class="headerlink" title="2. 邻接矩阵有向图"></a><strong>2. 邻接矩阵有向图</strong></h3><p><strong>基本定义</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MatrixDG</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">char</span>[] mVexs;       <span class="hljs-comment">// 顶点集合</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[][] mMatrix;    <span class="hljs-comment">// 邻接矩阵</span><br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>这里介绍提供了两个创建矩阵的方法。一个是<strong>用已知数据</strong>，另一个则<strong>需要用户手动输入数据</strong>。</p><h4 id="2-1-创建图-用已提供的矩阵"><a href="#2-1-创建图-用已提供的矩阵" class="headerlink" title="2.1 创建图(用已提供的矩阵)"></a><strong>2.1 创建图(用已提供的矩阵)</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*<br> * 创建图(用已提供的矩阵)<br> *<br> * 参数说明：<br> *     vexs  -- 顶点数组<br> *     edges -- 边数组<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MatrixDG</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] vexs, <span class="hljs-keyword">char</span>[][] edges)</span> </span>&#123;<br><br>    <span class="hljs-comment">// 初始化"顶点数"和"边数"</span><br>    <span class="hljs-keyword">int</span> vlen = vexs.length;<br>    <span class="hljs-keyword">int</span> elen = edges.length;<br><br>    <span class="hljs-comment">// 初始化"顶点"</span><br>    mVexs = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[vlen];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mVexs.length; i++)<br>        mVexs[i] = vexs[i];<br><br>    <span class="hljs-comment">// 初始化"边"</span><br>    mMatrix = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[vlen][vlen];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; elen; i++) &#123;<br>        <span class="hljs-comment">// 读取边的起始顶点和结束顶点</span><br>        <span class="hljs-keyword">int</span> p1 = getPosition(edges[i][<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">int</span> p2 = getPosition(edges[i][<span class="hljs-number">1</span>]);<br><br>        mMatrix[p1][p2] = <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数的作用是创建一个邻接矩阵有向图。实际上，该方法创建的有向图，就是上面的图G2。它的调用方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">char</span>[] vexs = &#123;<span class="hljs-string">'A'</span>, <span class="hljs-string">'B'</span>, <span class="hljs-string">'C'</span>, <span class="hljs-string">'D'</span>, <span class="hljs-string">'E'</span>, <span class="hljs-string">'F'</span>, <span class="hljs-string">'G'</span>&#125;;<br><span class="hljs-keyword">char</span>[][] edges = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[][]&#123;<br>    &#123;<span class="hljs-string">'A'</span>, <span class="hljs-string">'B'</span>&#125;, <br>    &#123;<span class="hljs-string">'B'</span>, <span class="hljs-string">'C'</span>&#125;, <br>    &#123;<span class="hljs-string">'B'</span>, <span class="hljs-string">'E'</span>&#125;, <br>    &#123;<span class="hljs-string">'B'</span>, <span class="hljs-string">'F'</span>&#125;, <br>    &#123;<span class="hljs-string">'C'</span>, <span class="hljs-string">'E'</span>&#125;, <br>    &#123;<span class="hljs-string">'D'</span>, <span class="hljs-string">'C'</span>&#125;, <br>    &#123;<span class="hljs-string">'E'</span>, <span class="hljs-string">'B'</span>&#125;, <br>    &#123;<span class="hljs-string">'E'</span>, <span class="hljs-string">'D'</span>&#125;, <br>    &#123;<span class="hljs-string">'F'</span>, <span class="hljs-string">'G'</span>&#125;&#125;; <br>MatrixDG pG;<br><br>pG = <span class="hljs-keyword">new</span> MatrixDG(vexs, edges);<br></code></pre></td></tr></table></figure><h4 id="2-2-创建图-自己输入"><a href="#2-2-创建图-自己输入" class="headerlink" title="2.2 创建图(自己输入)"></a><strong>2.2 创建图(自己输入)</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* <br> * 创建图(自己输入数据)<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MatrixDG</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-comment">// 输入"顶点数"和"边数"</span><br>    System.out.printf(<span class="hljs-string">"input vertex number: "</span>);<br>    <span class="hljs-keyword">int</span> vlen = readInt();<br>    System.out.printf(<span class="hljs-string">"input edge number: "</span>);<br>    <span class="hljs-keyword">int</span> elen = readInt();<br>    <span class="hljs-keyword">if</span> ( vlen &lt; <span class="hljs-number">1</span> || elen &lt; <span class="hljs-number">1</span> || (elen &gt; (vlen*(vlen - <span class="hljs-number">1</span>)))) &#123;<br>        System.out.printf(<span class="hljs-string">"input error: invalid parameters!\n"</span>);<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化"顶点"</span><br>    mVexs = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[vlen];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mVexs.length; i++) &#123;<br>        System.out.printf(<span class="hljs-string">"vertex(%d): "</span>, i);<br>        mVexs[i] = readChar();<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化"边"</span><br>    mMatrix = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[vlen][vlen];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; elen; i++) &#123;<br>        <span class="hljs-comment">// 读取边的起始顶点和结束顶点</span><br>        System.out.printf(<span class="hljs-string">"edge(%d):"</span>, i);<br>        <span class="hljs-keyword">char</span> c1 = readChar();<br>        <span class="hljs-keyword">char</span> c2 = readChar();<br>        <span class="hljs-keyword">int</span> p1 = getPosition(c1);<br>        <span class="hljs-keyword">int</span> p2 = getPosition(c2);<br><br>        <span class="hljs-keyword">if</span> (p1==-<span class="hljs-number">1</span> || p2==-<span class="hljs-number">1</span>) &#123;<br>            System.out.printf(<span class="hljs-string">"input error: invalid edge!\n"</span>);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br><br>        mMatrix[p1][p2] = <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-邻接表无向图"><a href="#3-邻接表无向图" class="headerlink" title="3. 邻接表无向图"></a><strong>3. 邻接表无向图</strong></h3><p><strong>基本定义</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListUDG</span> </span>&#123;<br>    <span class="hljs-comment">// 邻接表中表对应的链表的顶点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ENode</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ivex;       <span class="hljs-comment">// 该边所指向的顶点的位置</span><br>        ENode nextEdge; <span class="hljs-comment">// 指向下一条弧的指针</span><br>    &#125;<br><br>    <span class="hljs-comment">// 邻接表中表的顶点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VNode</span> </span>&#123;<br>        <span class="hljs-keyword">char</span> data;          <span class="hljs-comment">// 顶点信息</span><br>        ENode firstEdge;    <span class="hljs-comment">// 指向第一条依附该顶点的弧</span><br>    &#125;;<br><br>    <span class="hljs-keyword">private</span> VNode[] mVexs;  <span class="hljs-comment">// 顶点数组</span><br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>(1)</strong> ListUDG是邻接表对应的结构体。mVexs则是保存顶点信息的一维数组。<br><strong>(2)</strong> VNode是邻接表顶点对应的结构体。 data是顶点所包含的数据，而firstEdge是该顶点所包含链表的表头指针。<br><strong>(3)</strong> ENode是邻接表顶点所包含的链表的节点对应的结构体。 ivex是该节点所对应的顶点在vexs中的索引，而nextEdge是指向下一个节点的。</p><h4 id="3-1-创建图-用已提供的矩阵"><a href="#3-1-创建图-用已提供的矩阵" class="headerlink" title="3.1 创建图(用已提供的矩阵)"></a><strong>3.1 创建图(用已提供的矩阵)</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*<br> * 创建图(用已提供的矩阵)<br> *<br> * 参数说明：<br> *     vexs  -- 顶点数组<br> *     edges -- 边数组<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ListUDG</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] vexs, <span class="hljs-keyword">char</span>[][] edges)</span> </span>&#123;<br><br>    <span class="hljs-comment">// 初始化"顶点数"和"边数"</span><br>    <span class="hljs-keyword">int</span> vlen = vexs.length;<br>    <span class="hljs-keyword">int</span> elen = edges.length;<br><br>    <span class="hljs-comment">// 初始化"顶点"</span><br>    mVexs = <span class="hljs-keyword">new</span> VNode[vlen];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mVexs.length; i++) &#123;<br>        mVexs[i] = <span class="hljs-keyword">new</span> VNode();<br>        mVexs[i].data = vexs[i];<br>        mVexs[i].firstEdge = <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化"边"</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; elen; i++) &#123;<br>        <span class="hljs-comment">// 读取边的起始顶点和结束顶点</span><br>        <span class="hljs-keyword">char</span> c1 = edges[i][<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">char</span> c2 = edges[i][<span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// 读取边的起始顶点和结束顶点</span><br>        <span class="hljs-keyword">int</span> p1 = getPosition(edges[i][<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">int</span> p2 = getPosition(edges[i][<span class="hljs-number">1</span>]);<br>        <span class="hljs-comment">// 初始化node1</span><br>        ENode node1 = <span class="hljs-keyword">new</span> ENode();<br>        node1.ivex = p2;<br>        <span class="hljs-comment">// 将node1链接到"p1所在链表的末尾"</span><br>        <span class="hljs-keyword">if</span>(mVexs[p1].firstEdge == <span class="hljs-keyword">null</span>)<br>          mVexs[p1].firstEdge = node1;<br>        <span class="hljs-keyword">else</span><br>            linkLast(mVexs[p1].firstEdge, node1);<br>        <span class="hljs-comment">// 初始化node2</span><br>        ENode node2 = <span class="hljs-keyword">new</span> ENode();<br>        node2.ivex = p1;<br>        <span class="hljs-comment">// 将node2链接到"p2所在链表的末尾"</span><br>        <span class="hljs-keyword">if</span>(mVexs[p2].firstEdge == <span class="hljs-keyword">null</span>)<br>          mVexs[p2].firstEdge = node2;<br>        <span class="hljs-keyword">else</span><br>            linkLast(mVexs[p2].firstEdge, node2);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数的作用是创建一个邻接表无向图。实际上，该方法创建的无向图，就是上面图G1。调用代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">char</span>[] vexs = &#123;<span class="hljs-string">'A'</span>, <span class="hljs-string">'B'</span>, <span class="hljs-string">'C'</span>, <span class="hljs-string">'D'</span>, <span class="hljs-string">'E'</span>, <span class="hljs-string">'F'</span>, <span class="hljs-string">'G'</span>&#125;;<br><span class="hljs-keyword">char</span>[][] edges = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[][]&#123;<br>    &#123;<span class="hljs-string">'A'</span>, <span class="hljs-string">'C'</span>&#125;, <br>    &#123;<span class="hljs-string">'A'</span>, <span class="hljs-string">'D'</span>&#125;, <br>    &#123;<span class="hljs-string">'A'</span>, <span class="hljs-string">'F'</span>&#125;, <br>    &#123;<span class="hljs-string">'B'</span>, <span class="hljs-string">'C'</span>&#125;, <br>    &#123;<span class="hljs-string">'C'</span>, <span class="hljs-string">'D'</span>&#125;, <br>    &#123;<span class="hljs-string">'E'</span>, <span class="hljs-string">'G'</span>&#125;, <br>    &#123;<span class="hljs-string">'F'</span>, <span class="hljs-string">'G'</span>&#125;&#125;;<br>ListUDG pG;<br><br>pG = <span class="hljs-keyword">new</span> ListUDG(vexs, edges);<br></code></pre></td></tr></table></figure><h4 id="3-2-创建图-自己输入"><a href="#3-2-创建图-自己输入" class="headerlink" title="3.2 创建图(自己输入)"></a><strong>3.2 创建图(自己输入)</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* <br> * 创建图(自己输入数据)<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ListUDG</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-comment">// 输入"顶点数"和"边数"</span><br>    System.out.printf(<span class="hljs-string">"input vertex number: "</span>);<br>    <span class="hljs-keyword">int</span> vlen = readInt();<br>    System.out.printf(<span class="hljs-string">"input edge number: "</span>);<br>    <span class="hljs-keyword">int</span> elen = readInt();<br>    <span class="hljs-keyword">if</span> ( vlen &lt; <span class="hljs-number">1</span> || elen &lt; <span class="hljs-number">1</span> || (elen &gt; (vlen*(vlen - <span class="hljs-number">1</span>)))) &#123;<br>        System.out.printf(<span class="hljs-string">"input error: invalid parameters!\n"</span>);<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化"顶点"</span><br>    mVexs = <span class="hljs-keyword">new</span> VNode[vlen];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mVexs.length; i++) &#123;<br>        System.out.printf(<span class="hljs-string">"vertex(%d): "</span>, i);<br>        mVexs[i] = <span class="hljs-keyword">new</span> VNode();<br>        mVexs[i].data = readChar();<br>        mVexs[i].firstEdge = <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化"边"</span><br>    <span class="hljs-comment">//mMatrix = new int[vlen][vlen];</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; elen; i++) &#123;<br>        <span class="hljs-comment">// 读取边的起始顶点和结束顶点</span><br>        System.out.printf(<span class="hljs-string">"edge(%d):"</span>, i);<br>        <span class="hljs-keyword">char</span> c1 = readChar();<br>        <span class="hljs-keyword">char</span> c2 = readChar();<br>        <span class="hljs-keyword">int</span> p1 = getPosition(c1);<br>        <span class="hljs-keyword">int</span> p2 = getPosition(c2);<br>        <span class="hljs-comment">// 初始化node1</span><br>        ENode node1 = <span class="hljs-keyword">new</span> ENode();<br>        node1.ivex = p2;<br>        <span class="hljs-comment">// 将node1链接到"p1所在链表的末尾"</span><br>        <span class="hljs-keyword">if</span>(mVexs[p1].firstEdge == <span class="hljs-keyword">null</span>)<br>          mVexs[p1].firstEdge = node1;<br>        <span class="hljs-keyword">else</span><br>            linkLast(mVexs[p1].firstEdge, node1);<br>        <span class="hljs-comment">// 初始化node2</span><br>        ENode node2 = <span class="hljs-keyword">new</span> ENode();<br>        node2.ivex = p1;<br>        <span class="hljs-comment">// 将node2链接到"p2所在链表的末尾"</span><br>        <span class="hljs-keyword">if</span>(mVexs[p2].firstEdge == <span class="hljs-keyword">null</span>)<br>          mVexs[p2].firstEdge = node2;<br>        <span class="hljs-keyword">else</span><br>            linkLast(mVexs[p2].firstEdge, node2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-邻接表有向图"><a href="#4-邻接表有向图" class="headerlink" title="4. 邻接表有向图"></a><strong>4. 邻接表有向图</strong></h3><p><strong>基本定义</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListDG</span> </span>&#123;<br>    <span class="hljs-comment">// 邻接表中表对应的链表的顶点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ENode</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ivex;       <span class="hljs-comment">// 该边所指向的顶点的位置</span><br>        ENode nextEdge; <span class="hljs-comment">// 指向下一条弧的指针</span><br>    &#125;<br><br>    <span class="hljs-comment">// 邻接表中表的顶点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VNode</span> </span>&#123;<br>        <span class="hljs-keyword">char</span> data;          <span class="hljs-comment">// 顶点信息</span><br>        ENode firstEdge;    <span class="hljs-comment">// 指向第一条依附该顶点的弧</span><br>    &#125;;<br><br>    <span class="hljs-keyword">private</span> VNode[] mVexs;  <span class="hljs-comment">// 顶点数组</span><br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>(1)</strong> ListDG是邻接表对应的结构体。 mVexs则是保存顶点信息的一维数组。<br><strong>(2)</strong> VNode是邻接表顶点对应的结构体。 data是顶点所包含的数据，而firstEdge是该顶点所包含链表的表头指针。<br><strong>(3)</strong> ENode是邻接表顶点所包含的链表的节点对应的结构体。 ivex是该节点所对应的顶点在vexs中的索引，而nextEdge是指向下一个节点的。</p><h4 id="4-1-创建图-用已提供的矩阵"><a href="#4-1-创建图-用已提供的矩阵" class="headerlink" title="4.1 创建图(用已提供的矩阵)"></a><strong>4.1 创建图(用已提供的矩阵)</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*<br> * 创建图(用已提供的矩阵)<br> *<br> * 参数说明：<br> *     vexs  -- 顶点数组<br> *     edges -- 边数组<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ListDG</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] vexs, <span class="hljs-keyword">char</span>[][] edges)</span> </span>&#123;<br><br>    <span class="hljs-comment">// 初始化"顶点数"和"边数"</span><br>    <span class="hljs-keyword">int</span> vlen = vexs.length;<br>    <span class="hljs-keyword">int</span> elen = edges.length;<br><br>    <span class="hljs-comment">// 初始化"顶点"</span><br>    mVexs = <span class="hljs-keyword">new</span> VNode[vlen];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mVexs.length; i++) &#123;<br>        mVexs[i] = <span class="hljs-keyword">new</span> VNode();<br>        mVexs[i].data = vexs[i];<br>        mVexs[i].firstEdge = <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化"边"</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; elen; i++) &#123;<br>        <span class="hljs-comment">// 读取边的起始顶点和结束顶点</span><br>        <span class="hljs-keyword">char</span> c1 = edges[i][<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">char</span> c2 = edges[i][<span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// 读取边的起始顶点和结束顶点</span><br>        <span class="hljs-keyword">int</span> p1 = getPosition(edges[i][<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">int</span> p2 = getPosition(edges[i][<span class="hljs-number">1</span>]);<br><br>        <span class="hljs-comment">// 初始化node1</span><br>        ENode node1 = <span class="hljs-keyword">new</span> ENode();<br>        node1.ivex = p2;<br>        <span class="hljs-comment">// 将node1链接到"p1所在链表的末尾"</span><br>        <span class="hljs-keyword">if</span>(mVexs[p1].firstEdge == <span class="hljs-keyword">null</span>)<br>          mVexs[p1].firstEdge = node1;<br>        <span class="hljs-keyword">else</span><br>            linkLast(mVexs[p1].firstEdge, node1);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数的作用是创建一个邻接表有向图。实际上，该方法创建的有向图，就是上面的图G2。该函数的调用方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">char</span>[] vexs = &#123;<span class="hljs-string">'A'</span>, <span class="hljs-string">'B'</span>, <span class="hljs-string">'C'</span>, <span class="hljs-string">'D'</span>, <span class="hljs-string">'E'</span>, <span class="hljs-string">'F'</span>, <span class="hljs-string">'G'</span>&#125;;<br>    <span class="hljs-keyword">char</span>[][] edges = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[][]&#123;<br>        &#123;<span class="hljs-string">'A'</span>, <span class="hljs-string">'B'</span>&#125;, <br>        &#123;<span class="hljs-string">'B'</span>, <span class="hljs-string">'C'</span>&#125;, <br>        &#123;<span class="hljs-string">'B'</span>, <span class="hljs-string">'E'</span>&#125;, <br>        &#123;<span class="hljs-string">'B'</span>, <span class="hljs-string">'F'</span>&#125;, <br>        &#123;<span class="hljs-string">'C'</span>, <span class="hljs-string">'E'</span>&#125;, <br>        &#123;<span class="hljs-string">'D'</span>, <span class="hljs-string">'C'</span>&#125;, <br>        &#123;<span class="hljs-string">'E'</span>, <span class="hljs-string">'B'</span>&#125;, <br>        &#123;<span class="hljs-string">'E'</span>, <span class="hljs-string">'D'</span>&#125;, <br>        &#123;<span class="hljs-string">'F'</span>, <span class="hljs-string">'G'</span>&#125;&#125;; <br>    ListDG pG;<br><br>    pG = <span class="hljs-keyword">new</span> ListDG(vexs, edges);<br></code></pre></td></tr></table></figure><h4 id="4-2-创建图-自己输入"><a href="#4-2-创建图-自己输入" class="headerlink" title="4.2 创建图(自己输入)"></a><strong>4.2 创建图(自己输入)</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* <br> * 创建图(自己输入数据)<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ListDG</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-comment">// 输入"顶点数"和"边数"</span><br>    System.out.printf(<span class="hljs-string">"input vertex number: "</span>);<br>    <span class="hljs-keyword">int</span> vlen = readInt();<br>    System.out.printf(<span class="hljs-string">"input edge number: "</span>);<br>    <span class="hljs-keyword">int</span> elen = readInt();<br>    <span class="hljs-keyword">if</span> ( vlen &lt; <span class="hljs-number">1</span> || elen &lt; <span class="hljs-number">1</span> || (elen &gt; (vlen*(vlen - <span class="hljs-number">1</span>)))) &#123;<br>        System.out.printf(<span class="hljs-string">"input error: invalid parameters!\n"</span>);<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化"顶点"</span><br>    mVexs = <span class="hljs-keyword">new</span> VNode[vlen];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mVexs.length; i++) &#123;<br>        System.out.printf(<span class="hljs-string">"vertex(%d): "</span>, i);<br>        mVexs[i] = <span class="hljs-keyword">new</span> VNode();<br>        mVexs[i].data = readChar();<br>        mVexs[i].firstEdge = <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化"边"</span><br>    <span class="hljs-comment">//mMatrix = new int[vlen][vlen];</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; elen; i++) &#123;<br>        <span class="hljs-comment">// 读取边的起始顶点和结束顶点</span><br>        System.out.printf(<span class="hljs-string">"edge(%d):"</span>, i);<br>        <span class="hljs-keyword">char</span> c1 = readChar();<br>        <span class="hljs-keyword">char</span> c2 = readChar();<br>        <span class="hljs-keyword">int</span> p1 = getPosition(c1);<br>        <span class="hljs-keyword">int</span> p2 = getPosition(c2);<br>        <span class="hljs-comment">// 初始化node1</span><br>        ENode node1 = <span class="hljs-keyword">new</span> ENode();<br>        node1.ivex = p2;<br>        <span class="hljs-comment">// 将node1链接到"p1所在链表的末尾"</span><br>        <span class="hljs-keyword">if</span>(mVexs[p1].firstEdge == <span class="hljs-keyword">null</span>)<br>          mVexs[p1].firstEdge = node1;<br>        <span class="hljs-keyword">else</span><br>            linkLast(mVexs[p1].firstEdge, node1);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;图-graph&quot;&gt;&lt;a href=&quot;#图-graph&quot; class=&quot;headerlink&quot; title=&quot;图(graph)&quot;&gt;&lt;/a&gt;图(graph)&lt;/h1&gt;&lt;h2 id=&quot;一、基本概念&quot;&gt;&lt;a href=&quot;#一、基本概念&quot; class=&quot;headerlink
      
    
    </summary>
    
    
      <category term="Data Structure" scheme="http://yoursite.com/categories/Data-Structure/"/>
    
    
      <category term="Data Structure" scheme="http://yoursite.com/tags/Data-Structure/"/>
    
  </entry>
  
</feed>
